import { inject, NgModule, } from '@angular/core';
import { EffectsFeatureModule } from './effects_feature_module';
import { EffectsRootModule } from './effects_root_module';
import { EffectsRunner } from './effects_runner';
import { _FEATURE_EFFECTS, _ROOT_EFFECTS, _ROOT_EFFECTS_GUARD, _FEATURE_EFFECTS_INSTANCE_GROUPS, _ROOT_EFFECTS_INSTANCES, USER_PROVIDED_EFFECTS, } from './tokens';
import { getClasses, isToken } from './utils';
import * as i0 from "@angular/core";
class EffectsModule {
    static forFeature(...featureEffects) {
        const effects = featureEffects.flat();
        const effectsClasses = getClasses(effects);
        return {
            ngModule: EffectsFeatureModule,
            providers: [
                effectsClasses,
                {
                    provide: _FEATURE_EFFECTS,
                    multi: true,
                    useValue: effects,
                },
                {
                    provide: USER_PROVIDED_EFFECTS,
                    multi: true,
                    useValue: [],
                },
                {
                    provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,
                    multi: true,
                    useFactory: createEffectsInstances,
                    deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],
                },
            ],
        };
    }
    static forRoot(...rootEffects) {
        const effects = rootEffects.flat();
        const effectsClasses = getClasses(effects);
        return {
            ngModule: EffectsRootModule,
            providers: [
                effectsClasses,
                {
                    provide: _ROOT_EFFECTS,
                    useValue: [effects],
                },
                {
                    provide: _ROOT_EFFECTS_GUARD,
                    useFactory: _provideForRootGuard,
                },
                {
                    provide: USER_PROVIDED_EFFECTS,
                    multi: true,
                    useValue: [],
                },
                {
                    provide: _ROOT_EFFECTS_INSTANCES,
                    useFactory: createEffectsInstances,
                    deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS],
                },
            ],
        };
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: EffectsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    /** @nocollapse */ static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.0", ngImport: i0, type: EffectsModule }); }
    /** @nocollapse */ static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: EffectsModule }); }
}
export { EffectsModule };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: EffectsModule, decorators: [{
            type: NgModule,
            args: [{}]
        }] });
function createEffectsInstances(effectsGroups, userProvidedEffectsGroups) {
    const effects = [];
    for (const effectsGroup of effectsGroups) {
        effects.push(...effectsGroup);
    }
    for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {
        effects.push(...userProvidedEffectsGroup);
    }
    return effects.map((effectsTokenOrRecord) => isToken(effectsTokenOrRecord)
        ? inject(effectsTokenOrRecord)
        : effectsTokenOrRecord);
}
function _provideForRootGuard() {
    const runner = inject(EffectsRunner, { optional: true, skipSelf: true });
    const rootEffects = inject(_ROOT_EFFECTS, { self: true });
    // check whether any effects are actually passed
    const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);
    if (hasEffects && runner) {
        throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);
    }
    return 'guarded';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWZmZWN0c19tb2R1bGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2VmZmVjdHMvc3JjL2VmZmVjdHNfbW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxNQUFNLEVBR04sUUFBUSxHQUVULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzFELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLGFBQWEsRUFDYixtQkFBbUIsRUFDbkIsZ0NBQWdDLEVBQ2hDLHVCQUF1QixFQUN2QixxQkFBcUIsR0FDdEIsTUFBTSxVQUFVLENBQUM7QUFFbEIsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxTQUFTLENBQUM7O0FBRTlDLE1BQ2EsYUFBYTtJQU94QixNQUFNLENBQUMsVUFBVSxDQUNmLEdBQUcsY0FFMEQ7UUFFN0QsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3RDLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQyxPQUFPO1lBQ0wsUUFBUSxFQUFFLG9CQUFvQjtZQUM5QixTQUFTLEVBQUU7Z0JBQ1QsY0FBYztnQkFDZDtvQkFDRSxPQUFPLEVBQUUsZ0JBQWdCO29CQUN6QixLQUFLLEVBQUUsSUFBSTtvQkFDWCxRQUFRLEVBQUUsT0FBTztpQkFDbEI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLHFCQUFxQjtvQkFDOUIsS0FBSyxFQUFFLElBQUk7b0JBQ1gsUUFBUSxFQUFFLEVBQUU7aUJBQ2I7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLGdDQUFnQztvQkFDekMsS0FBSyxFQUFFLElBQUk7b0JBQ1gsVUFBVSxFQUFFLHNCQUFzQjtvQkFDbEMsSUFBSSxFQUFFLENBQUMsZ0JBQWdCLEVBQUUscUJBQXFCLENBQUM7aUJBQ2hEO2FBQ0Y7U0FDRixDQUFDO0lBQ0osQ0FBQztJQVFELE1BQU0sQ0FBQyxPQUFPLENBQ1osR0FBRyxXQUUwRDtRQUU3RCxNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbkMsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNDLE9BQU87WUFDTCxRQUFRLEVBQUUsaUJBQWlCO1lBQzNCLFNBQVMsRUFBRTtnQkFDVCxjQUFjO2dCQUNkO29CQUNFLE9BQU8sRUFBRSxhQUFhO29CQUN0QixRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUM7aUJBQ3BCO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxtQkFBbUI7b0JBQzVCLFVBQVUsRUFBRSxvQkFBb0I7aUJBQ2pDO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxxQkFBcUI7b0JBQzlCLEtBQUssRUFBRSxJQUFJO29CQUNYLFFBQVEsRUFBRSxFQUFFO2lCQUNiO2dCQUNEO29CQUNFLE9BQU8sRUFBRSx1QkFBdUI7b0JBQ2hDLFVBQVUsRUFBRSxzQkFBc0I7b0JBQ2xDLElBQUksRUFBRSxDQUFDLGFBQWEsRUFBRSxxQkFBcUIsQ0FBQztpQkFDN0M7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDO2lJQTNFVSxhQUFhO2tJQUFiLGFBQWE7a0lBQWIsYUFBYTs7U0FBYixhQUFhOzJGQUFiLGFBQWE7a0JBRHpCLFFBQVE7bUJBQUMsRUFBRTs7QUErRVosU0FBUyxzQkFBc0IsQ0FDN0IsYUFBd0UsRUFDeEUseUJBQTJFO0lBRTNFLE1BQU0sT0FBTyxHQUVULEVBQUUsQ0FBQztJQUVQLEtBQUssTUFBTSxZQUFZLElBQUksYUFBYSxFQUFFO1FBQ3hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQztLQUMvQjtJQUVELEtBQUssTUFBTSx3QkFBd0IsSUFBSSx5QkFBeUIsRUFBRTtRQUNoRSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsd0JBQXdCLENBQUMsQ0FBQztLQUMzQztJQUVELE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFLEVBQUUsQ0FDMUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDO1FBQzNCLENBQUMsQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUM7UUFDOUIsQ0FBQyxDQUFDLG9CQUFvQixDQUN6QixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsb0JBQW9CO0lBQzNCLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxhQUFhLEVBQUUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3pFLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxhQUFhLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUUxRCxnREFBZ0Q7SUFDaEQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDOUUsSUFBSSxVQUFVLElBQUksTUFBTSxFQUFFO1FBQ3hCLE1BQU0sSUFBSSxTQUFTLENBQ2pCLHNHQUFzRyxDQUN2RyxDQUFDO0tBQ0g7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaW5qZWN0LFxuICBJbmplY3Rpb25Ub2tlbixcbiAgTW9kdWxlV2l0aFByb3ZpZGVycyxcbiAgTmdNb2R1bGUsXG4gIFR5cGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRWZmZWN0c0ZlYXR1cmVNb2R1bGUgfSBmcm9tICcuL2VmZmVjdHNfZmVhdHVyZV9tb2R1bGUnO1xuaW1wb3J0IHsgRWZmZWN0c1Jvb3RNb2R1bGUgfSBmcm9tICcuL2VmZmVjdHNfcm9vdF9tb2R1bGUnO1xuaW1wb3J0IHsgRWZmZWN0c1J1bm5lciB9IGZyb20gJy4vZWZmZWN0c19ydW5uZXInO1xuaW1wb3J0IHtcbiAgX0ZFQVRVUkVfRUZGRUNUUyxcbiAgX1JPT1RfRUZGRUNUUyxcbiAgX1JPT1RfRUZGRUNUU19HVUFSRCxcbiAgX0ZFQVRVUkVfRUZGRUNUU19JTlNUQU5DRV9HUk9VUFMsXG4gIF9ST09UX0VGRkVDVFNfSU5TVEFOQ0VTLFxuICBVU0VSX1BST1ZJREVEX0VGRkVDVFMsXG59IGZyb20gJy4vdG9rZW5zJztcbmltcG9ydCB7IEZ1bmN0aW9uYWxFZmZlY3QgfSBmcm9tICcuL21vZGVscyc7XG5pbXBvcnQgeyBnZXRDbGFzc2VzLCBpc1Rva2VuIH0gZnJvbSAnLi91dGlscyc7XG5cbkBOZ01vZHVsZSh7fSlcbmV4cG9ydCBjbGFzcyBFZmZlY3RzTW9kdWxlIHtcbiAgc3RhdGljIGZvckZlYXR1cmUoXG4gICAgZmVhdHVyZUVmZmVjdHM6IEFycmF5PFR5cGU8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbmFsRWZmZWN0Pj5cbiAgKTogTW9kdWxlV2l0aFByb3ZpZGVyczxFZmZlY3RzRmVhdHVyZU1vZHVsZT47XG4gIHN0YXRpYyBmb3JGZWF0dXJlKFxuICAgIC4uLmZlYXR1cmVFZmZlY3RzOiBBcnJheTxUeXBlPHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgRnVuY3Rpb25hbEVmZmVjdD4+XG4gICk6IE1vZHVsZVdpdGhQcm92aWRlcnM8RWZmZWN0c0ZlYXR1cmVNb2R1bGU+O1xuICBzdGF0aWMgZm9yRmVhdHVyZShcbiAgICAuLi5mZWF0dXJlRWZmZWN0czpcbiAgICAgIHwgQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+PlxuICAgICAgfCBbQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+Pl1cbiAgKTogTW9kdWxlV2l0aFByb3ZpZGVyczxFZmZlY3RzRmVhdHVyZU1vZHVsZT4ge1xuICAgIGNvbnN0IGVmZmVjdHMgPSBmZWF0dXJlRWZmZWN0cy5mbGF0KCk7XG4gICAgY29uc3QgZWZmZWN0c0NsYXNzZXMgPSBnZXRDbGFzc2VzKGVmZmVjdHMpO1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogRWZmZWN0c0ZlYXR1cmVNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgZWZmZWN0c0NsYXNzZXMsXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBfRkVBVFVSRV9FRkZFQ1RTLFxuICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgIHVzZVZhbHVlOiBlZmZlY3RzLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogVVNFUl9QUk9WSURFRF9FRkZFQ1RTLFxuICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgIHVzZVZhbHVlOiBbXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IF9GRUFUVVJFX0VGRkVDVFNfSU5TVEFOQ0VfR1JPVVBTLFxuICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgIHVzZUZhY3Rvcnk6IGNyZWF0ZUVmZmVjdHNJbnN0YW5jZXMsXG4gICAgICAgICAgZGVwczogW19GRUFUVVJFX0VGRkVDVFMsIFVTRVJfUFJPVklERURfRUZGRUNUU10sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZm9yUm9vdChcbiAgICByb290RWZmZWN0czogQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+PlxuICApOiBNb2R1bGVXaXRoUHJvdmlkZXJzPEVmZmVjdHNSb290TW9kdWxlPjtcbiAgc3RhdGljIGZvclJvb3QoXG4gICAgLi4ucm9vdEVmZmVjdHM6IEFycmF5PFR5cGU8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbmFsRWZmZWN0Pj5cbiAgKTogTW9kdWxlV2l0aFByb3ZpZGVyczxFZmZlY3RzUm9vdE1vZHVsZT47XG4gIHN0YXRpYyBmb3JSb290KFxuICAgIC4uLnJvb3RFZmZlY3RzOlxuICAgICAgfCBBcnJheTxUeXBlPHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgRnVuY3Rpb25hbEVmZmVjdD4+XG4gICAgICB8IFtBcnJheTxUeXBlPHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgRnVuY3Rpb25hbEVmZmVjdD4+XVxuICApOiBNb2R1bGVXaXRoUHJvdmlkZXJzPEVmZmVjdHNSb290TW9kdWxlPiB7XG4gICAgY29uc3QgZWZmZWN0cyA9IHJvb3RFZmZlY3RzLmZsYXQoKTtcbiAgICBjb25zdCBlZmZlY3RzQ2xhc3NlcyA9IGdldENsYXNzZXMoZWZmZWN0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBFZmZlY3RzUm9vdE1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBlZmZlY3RzQ2xhc3NlcyxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IF9ST09UX0VGRkVDVFMsXG4gICAgICAgICAgdXNlVmFsdWU6IFtlZmZlY3RzXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IF9ST09UX0VGRkVDVFNfR1VBUkQsXG4gICAgICAgICAgdXNlRmFjdG9yeTogX3Byb3ZpZGVGb3JSb290R3VhcmQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBVU0VSX1BST1ZJREVEX0VGRkVDVFMsXG4gICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgdXNlVmFsdWU6IFtdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogX1JPT1RfRUZGRUNUU19JTlNUQU5DRVMsXG4gICAgICAgICAgdXNlRmFjdG9yeTogY3JlYXRlRWZmZWN0c0luc3RhbmNlcyxcbiAgICAgICAgICBkZXBzOiBbX1JPT1RfRUZGRUNUUywgVVNFUl9QUk9WSURFRF9FRkZFQ1RTXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFZmZlY3RzSW5zdGFuY2VzKFxuICBlZmZlY3RzR3JvdXBzOiBBcnJheTxUeXBlPHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgRnVuY3Rpb25hbEVmZmVjdD4+W10sXG4gIHVzZXJQcm92aWRlZEVmZmVjdHNHcm91cHM6IEFycmF5PFR5cGU8dW5rbm93bj4gfCBJbmplY3Rpb25Ub2tlbjx1bmtub3duPj5bXVxuKTogdW5rbm93bltdIHtcbiAgY29uc3QgZWZmZWN0czogQXJyYXk8XG4gICAgVHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+IHwgSW5qZWN0aW9uVG9rZW48dW5rbm93bj5cbiAgPiA9IFtdO1xuXG4gIGZvciAoY29uc3QgZWZmZWN0c0dyb3VwIG9mIGVmZmVjdHNHcm91cHMpIHtcbiAgICBlZmZlY3RzLnB1c2goLi4uZWZmZWN0c0dyb3VwKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdXNlclByb3ZpZGVkRWZmZWN0c0dyb3VwIG9mIHVzZXJQcm92aWRlZEVmZmVjdHNHcm91cHMpIHtcbiAgICBlZmZlY3RzLnB1c2goLi4udXNlclByb3ZpZGVkRWZmZWN0c0dyb3VwKTtcbiAgfVxuXG4gIHJldHVybiBlZmZlY3RzLm1hcCgoZWZmZWN0c1Rva2VuT3JSZWNvcmQpID0+XG4gICAgaXNUb2tlbihlZmZlY3RzVG9rZW5PclJlY29yZClcbiAgICAgID8gaW5qZWN0KGVmZmVjdHNUb2tlbk9yUmVjb3JkKVxuICAgICAgOiBlZmZlY3RzVG9rZW5PclJlY29yZFxuICApO1xufVxuXG5mdW5jdGlvbiBfcHJvdmlkZUZvclJvb3RHdWFyZCgpOiB1bmtub3duIHtcbiAgY29uc3QgcnVubmVyID0gaW5qZWN0KEVmZmVjdHNSdW5uZXIsIHsgb3B0aW9uYWw6IHRydWUsIHNraXBTZWxmOiB0cnVlIH0pO1xuICBjb25zdCByb290RWZmZWN0cyA9IGluamVjdChfUk9PVF9FRkZFQ1RTLCB7IHNlbGY6IHRydWUgfSk7XG5cbiAgLy8gY2hlY2sgd2hldGhlciBhbnkgZWZmZWN0cyBhcmUgYWN0dWFsbHkgcGFzc2VkXG4gIGNvbnN0IGhhc0VmZmVjdHMgPSAhKHJvb3RFZmZlY3RzLmxlbmd0aCA9PT0gMSAmJiByb290RWZmZWN0c1swXS5sZW5ndGggPT09IDApO1xuICBpZiAoaGFzRWZmZWN0cyAmJiBydW5uZXIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYEVmZmVjdHNNb2R1bGUuZm9yUm9vdCgpIGNhbGxlZCB0d2ljZS4gRmVhdHVyZSBtb2R1bGVzIHNob3VsZCB1c2UgRWZmZWN0c01vZHVsZS5mb3JGZWF0dXJlKCkgaW5zdGVhZC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gJ2d1YXJkZWQnO1xufVxuIl19