import { from, of, iif, throwError } from 'rxjs';
import { Inject, Injectable } from '@angular/core';
import { isHttpInterceptorRouteConfig, } from './auth.config';
import { switchMap, first, concatMap, catchError, tap, filter, mergeMap, mapTo, pluck, } from 'rxjs/operators';
import { Auth0ClientService } from './auth.client';
import * as i0 from "@angular/core";
import * as i1 from "./auth.config";
import * as i2 from "./auth.state";
import * as i3 from "./auth.service";
import * as i4 from "@auth0/auth0-spa-js";
const waitUntil = (signal$) => (source$) => source$.pipe(mergeMap((value) => signal$.pipe(first(), mapTo(value))));
export class AuthHttpInterceptor {
    constructor(configFactory, auth0Client, authState, authService) {
        this.configFactory = configFactory;
        this.auth0Client = auth0Client;
        this.authState = authState;
        this.authService = authService;
    }
    intercept(req, next) {
        const config = this.configFactory.get();
        if (!config.httpInterceptor?.allowedList) {
            return next.handle(req);
        }
        const isLoaded$ = this.authService.isLoading$.pipe(filter((isLoading) => !isLoading));
        return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap((route) => iif(
        // Check if a route was matched
        () => route !== null, 
        // If we have a matching route, call getTokenSilently and attach the token to the
        // outgoing request
        of(route).pipe(waitUntil(isLoaded$), pluck('tokenOptions'), concatMap((options) => this.getAccessTokenSilently(options).pipe(catchError((err) => {
            if (this.allowAnonymous(route, err)) {
                return of('');
            }
            this.authState.setError(err);
            return throwError(err);
        }))), switchMap((token) => {
            // Clone the request and attach the bearer token
            const clone = token
                ? req.clone({
                    headers: req.headers.set('Authorization', `Bearer ${token}`),
                })
                : req;
            return next.handle(clone);
        })), 
        // If the URI being called was not found in our httpInterceptor config, simply
        // pass the request through without attaching a token
        next.handle(req))));
    }
    /**
     * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.
     * Only used internally in the interceptor.
     *
     * @param options The options for configuring the token fetch.
     */
    getAccessTokenSilently(options) {
        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenSilently(options)), tap((token) => this.authState.setAccessToken(token)), catchError((error) => {
            this.authState.refresh();
            return throwError(error);
        }));
    }
    /**
     * Strips the query and fragment from the given uri
     *
     * @param uri The uri to remove the query and fragment from
     */
    stripQueryFrom(uri) {
        if (uri.indexOf('?') > -1) {
            uri = uri.substr(0, uri.indexOf('?'));
        }
        if (uri.indexOf('#') > -1) {
            uri = uri.substr(0, uri.indexOf('#'));
        }
        return uri;
    }
    /**
     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against
     * the interceptor route configuration.
     *
     * @param route The route to test
     * @param request The HTTP request
     */
    canAttachToken(route, request) {
        const testPrimitive = (value) => {
            if (!value) {
                return false;
            }
            const requestPath = this.stripQueryFrom(request.url);
            if (value === requestPath) {
                return true;
            }
            // If the URL ends with an asterisk, match using startsWith.
            return (value.indexOf('*') === value.length - 1 &&
                request.url.startsWith(value.substr(0, value.length - 1)));
        };
        if (isHttpInterceptorRouteConfig(route)) {
            if (route.httpMethod && route.httpMethod !== request.method) {
                return false;
            }
            /* istanbul ignore if */
            if (!route.uri && !route.uriMatcher) {
                console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');
            }
            return route.uriMatcher
                ? route.uriMatcher(request.url)
                : testPrimitive(route.uri);
        }
        return testPrimitive(route);
    }
    /**
     * Tries to match a route from the SDK configuration to the HTTP request.
     * If a match is found, the route configuration is returned.
     *
     * @param request The Http request
     * @param config HttpInterceptorConfig
     */
    findMatchingRoute(request, config) {
        return from(config.allowedList).pipe(first((route) => this.canAttachToken(route, request), null));
    }
    allowAnonymous(route, err) {
        return (!!route &&
            isHttpInterceptorRouteConfig(route) &&
            !!route.allowAnonymous &&
            ['login_required', 'consent_required', 'missing_refresh_token'].includes(err.error));
    }
}
AuthHttpInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AuthHttpInterceptor, deps: [{ token: i1.AuthClientConfig }, { token: Auth0ClientService }, { token: i2.AuthState }, { token: i3.AuthService }], target: i0.ɵɵFactoryTarget.Injectable });
AuthHttpInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AuthHttpInterceptor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AuthHttpInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.AuthClientConfig }, { type: i4.Auth0Client, decorators: [{
                    type: Inject,
                    args: [Auth0ClientService]
                }] }, { type: i2.AuthState }, { type: i3.AuthService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2F1dGgwLWFuZ3VsYXIvc3JjL2xpYi9hdXRoLmludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLE9BQU8sRUFBYyxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkQsT0FBTyxFQUVMLDRCQUE0QixHQUc3QixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLEdBQUcsRUFDSCxNQUFNLEVBQ04sUUFBUSxFQUNSLEtBQUssRUFDTCxLQUFLLEdBQ04sTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7OztBQUluRCxNQUFNLFNBQVMsR0FDYixDQUFVLE9BQTRCLEVBQUUsRUFBRSxDQUMxQyxDQUFVLE9BQTRCLEVBQUUsRUFBRSxDQUN4QyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFHM0UsTUFBTSxPQUFPLG1CQUFtQjtJQUM5QixZQUNVLGFBQStCLEVBQ0gsV0FBd0IsRUFDcEQsU0FBb0IsRUFDcEIsV0FBd0I7UUFIeEIsa0JBQWEsR0FBYixhQUFhLENBQWtCO1FBQ0gsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDcEQsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNwQixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtJQUMvQixDQUFDO0lBRUosU0FB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LElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRTtnQkFDbkMsT0FBTyxDQUFDLElBQUksQ0FDViwrRUFBK0UsQ0FDaEYsQ0FBQzthQUNIO1lBRUQsT0FBTyxLQUFLLENBQUMsVUFBVTtnQkFDckIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztnQkFDL0IsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDOUI7UUFFRCxPQUFPLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssaUJBQWlCLENBQ3ZCLE9BQXlCLEVBQ3pCLE1BQTZCO1FBRTdCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQ2xDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQzVELENBQUM7SUFDSixDQUFDO0lBRU8sY0FBYyxDQUFDLEtBQWdDLEVBQUUsR0FBUTtRQUMvRCxPQUFPLENBQ0wsQ0FBQyxDQUFDLEtBQUs7WUFDUCw0QkFBNEIsQ0FBQyxLQUFLLENBQUM7WUFDbkMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjO1lBQ3RCLENBQUMsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsdUJBQXVCLENBQUMsQ0FBQyxRQUFRLENBQ3RFLEdBQUcsQ0FBQyxLQUFLLENBQ1YsQ0FDRixDQUFDO0lBQ0osQ0FBQzs7aUhBL0tVLG1CQUFtQixrREFHcEIsa0JBQWtCO3FIQUhqQixtQkFBbUI7NEZBQW5CLG1CQUFtQjtrQkFEL0IsVUFBVTs7MEJBSU4sTUFBTTsyQkFBQyxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIdHRwSW50ZXJjZXB0b3IsXG4gIEh0dHBSZXF1ZXN0LFxuICBIdHRwSGFuZGxlcixcbiAgSHR0cEV2ZW50LFxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5cbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIG9mLCBpaWYsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1xuICBBcGlSb3V0ZURlZmluaXRpb24sXG4gIGlzSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcsXG4gIEF1dGhDbGllbnRDb25maWcsXG4gIEh0dHBJbnRlcmNlcHRvckNvbmZpZyxcbn0gZnJvbSAnLi9hdXRoLmNvbmZpZyc7XG5cbmltcG9ydCB7XG4gIHN3aXRjaE1hcCxcbiAgZmlyc3QsXG4gIGNvbmNhdE1hcCxcbiAgY2F0Y2hFcnJvcixcbiAgdGFwLFxuICBmaWx0ZXIsXG4gIG1lcmdlTWFwLFxuICBtYXBUbyxcbiAgcGx1Y2ssXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEF1dGgwQ2xpZW50LCBHZXRUb2tlblNpbGVudGx5T3B0aW9ucyB9IGZyb20gJ0BhdXRoMC9hdXRoMC1zcGEtanMnO1xuaW1wb3J0IHsgQXV0aDBDbGllbnRTZXJ2aWNlIH0gZnJvbSAnLi9hdXRoLmNsaWVudCc7XG5pbXBvcnQgeyBBdXRoU3RhdGUgfSBmcm9tICcuL2F1dGguc3RhdGUnO1xuaW1wb3J0IHsgQXV0aFNlcnZpY2UgfSBmcm9tICcuL2F1dGguc2VydmljZSc7XG5cbmNvbnN0IHdhaXRVbnRpbCA9XG4gIDxUU2lnbmFsPihzaWduYWwkOiBPYnNlcnZhYmxlPFRTaWduYWw+KSA9PlxuICA8VFNvdXJjZT4oc291cmNlJDogT2JzZXJ2YWJsZTxUU291cmNlPikgPT5cbiAgICBzb3VyY2UkLnBpcGUobWVyZ2VNYXAoKHZhbHVlKSA9PiBzaWduYWwkLnBpcGUoZmlyc3QoKSwgbWFwVG8odmFsdWUpKSkpO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQXV0aEh0dHBJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY29uZmlnRmFjdG9yeTogQXV0aENsaWVudENvbmZpZyxcbiAgICBASW5qZWN0KEF1dGgwQ2xpZW50U2VydmljZSkgcHJpdmF0ZSBhdXRoMENsaWVudDogQXV0aDBDbGllbnQsXG4gICAgcHJpdmF0ZSBhdXRoU3RhdGU6IEF1dGhTdGF0ZSxcbiAgICBwcml2YXRlIGF1dGhTZXJ2aWNlOiBBdXRoU2VydmljZVxuICApIHt9XG5cbiAgaW50ZXJjZXB0KFxuICAgIHJlcTogSHR0cFJlcXVlc3Q8YW55PixcbiAgICBuZXh0OiBIdHRwSGFuZGxlclxuICApOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWdGYWN0b3J5LmdldCgpO1xuICAgIGlmICghY29uZmlnLmh0dHBJbnRlcmNlcHRvcj8uYWxsb3dlZExpc3QpIHtcbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzTG9hZGVkJCA9IHRoaXMuYXV0aFNlcnZpY2UuaXNMb2FkaW5nJC5waXBlKFxuICAgICAgZmlsdGVyKChpc0xvYWRpbmcpID0+ICFpc0xvYWRpbmcpXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmRNYXRjaGluZ1JvdXRlKHJlcSwgY29uZmlnLmh0dHBJbnRlcmNlcHRvcikucGlwZShcbiAgICAgIGNvbmNhdE1hcCgocm91dGUpID0+XG4gICAgICAgIGlpZihcbiAgICAgICAgICAvLyBDaGVjayBpZiBhIHJvdXRlIHdhcyBtYXRjaGVkXG4gICAgICAgICAgKCkgPT4gcm91dGUgIT09IG51bGwsXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1hdGNoaW5nIHJvdXRlLCBjYWxsIGdldFRva2VuU2lsZW50bHkgYW5kIGF0dGFjaCB0aGUgdG9rZW4gdG8gdGhlXG4gICAgICAgICAgLy8gb3V0Z29pbmcgcmVxdWVzdFxuICAgICAgICAgIG9mKHJvdXRlKS5waXBlKFxuICAgICAgICAgICAgd2FpdFVudGlsKGlzTG9hZGVkJCksXG4gICAgICAgICAgICBwbHVjaygndG9rZW5PcHRpb25zJyksXG4gICAgICAgICAgICBjb25jYXRNYXA8R2V0VG9rZW5TaWxlbnRseU9wdGlvbnMsIE9ic2VydmFibGU8c3RyaW5nPj4oKG9wdGlvbnMpID0+XG4gICAgICAgICAgICAgIHRoaXMuZ2V0QWNjZXNzVG9rZW5TaWxlbnRseShvcHRpb25zKS5waXBlKFxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dBbm9ueW1vdXMocm91dGUsIGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKCcnKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHN3aXRjaE1hcCgodG9rZW46IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgcmVxdWVzdCBhbmQgYXR0YWNoIHRoZSBiZWFyZXIgdG9rZW5cbiAgICAgICAgICAgICAgY29uc3QgY2xvbmUgPSB0b2tlblxuICAgICAgICAgICAgICAgID8gcmVxLmNsb25lKHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVxLmhlYWRlcnMuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IHJlcTtcblxuICAgICAgICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUoY2xvbmUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIElmIHRoZSBVUkkgYmVpbmcgY2FsbGVkIHdhcyBub3QgZm91bmQgaW4gb3VyIGh0dHBJbnRlcmNlcHRvciBjb25maWcsIHNpbXBseVxuICAgICAgICAgIC8vIHBhc3MgdGhlIHJlcXVlc3QgdGhyb3VnaCB3aXRob3V0IGF0dGFjaGluZyBhIHRva2VuXG4gICAgICAgICAgbmV4dC5oYW5kbGUocmVxKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEdXBsaWNhdGUgb2YgQXV0aFNlcnZpY2UuZ2V0QWNjZXNzVG9rZW5TaWxlbnRseSwgYnV0IHdpdGggYSBzbGlnaHRseSBkaWZmZXJlbnQgZXJyb3IgaGFuZGxpbmcuXG4gICAqIE9ubHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoZSBpbnRlcmNlcHRvci5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSB0b2tlbiBmZXRjaC5cbiAgICovXG4gIHByaXZhdGUgZ2V0QWNjZXNzVG9rZW5TaWxlbnRseShcbiAgICBvcHRpb25zPzogR2V0VG9rZW5TaWxlbnRseU9wdGlvbnNcbiAgKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gb2YodGhpcy5hdXRoMENsaWVudCkucGlwZShcbiAgICAgIGNvbmNhdE1hcCgoY2xpZW50KSA9PiBjbGllbnQuZ2V0VG9rZW5TaWxlbnRseShvcHRpb25zKSksXG4gICAgICB0YXAoKHRva2VuKSA9PiB0aGlzLmF1dGhTdGF0ZS5zZXRBY2Nlc3NUb2tlbih0b2tlbikpLFxuICAgICAgY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXBzIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQgZnJvbSB0aGUgZ2l2ZW4gdXJpXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgVGhlIHVyaSB0byByZW1vdmUgdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudCBmcm9tXG4gICAqL1xuICBwcml2YXRlIHN0cmlwUXVlcnlGcm9tKHVyaTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodXJpLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICB1cmkgPSB1cmkuc3Vic3RyKDAsIHVyaS5pbmRleE9mKCc/JykpO1xuICAgIH1cblxuICAgIGlmICh1cmkuaW5kZXhPZignIycpID4gLTEpIHtcbiAgICAgIHVyaSA9IHVyaS5zdWJzdHIoMCwgdXJpLmluZGV4T2YoJyMnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCByb3V0ZSBjYW4gaGF2ZSBhbiBhY2Nlc3MgdG9rZW4gYXR0YWNoZWQgdG8gaXQsIGJhc2VkIG9uIG1hdGNoaW5nIHRoZSBIVFRQIHJlcXVlc3QgYWdhaW5zdFxuICAgKiB0aGUgaW50ZXJjZXB0b3Igcm91dGUgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHJvdXRlIFRoZSByb3V0ZSB0byB0ZXN0XG4gICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBIVFRQIHJlcXVlc3RcbiAgICovXG4gIHByaXZhdGUgY2FuQXR0YWNoVG9rZW4oXG4gICAgcm91dGU6IEFwaVJvdXRlRGVmaW5pdGlvbixcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRlc3RQcmltaXRpdmUgPSAodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IGJvb2xlYW4gPT4ge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RQYXRoID0gdGhpcy5zdHJpcFF1ZXJ5RnJvbShyZXF1ZXN0LnVybCk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gcmVxdWVzdFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBVUkwgZW5kcyB3aXRoIGFuIGFzdGVyaXNrLCBtYXRjaCB1c2luZyBzdGFydHNXaXRoLlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdmFsdWUuaW5kZXhPZignKicpID09PSB2YWx1ZS5sZW5ndGggLSAxICYmXG4gICAgICAgIHJlcXVlc3QudXJsLnN0YXJ0c1dpdGgodmFsdWUuc3Vic3RyKDAsIHZhbHVlLmxlbmd0aCAtIDEpKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcocm91dGUpKSB7XG4gICAgICBpZiAocm91dGUuaHR0cE1ldGhvZCAmJiByb3V0ZS5odHRwTWV0aG9kICE9PSByZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFyb3V0ZS51cmkgJiYgIXJvdXRlLnVyaU1hdGNoZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdFaXRoZXIgYSB1cmkgb3IgdXJpTWF0Y2hlciBpcyByZXF1aXJlZCB3aGVuIGNvbmZpZ3VyaW5nIHRoZSBIVFRQIGludGVyY2VwdG9yLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdXRlLnVyaU1hdGNoZXJcbiAgICAgICAgPyByb3V0ZS51cmlNYXRjaGVyKHJlcXVlc3QudXJsKVxuICAgICAgICA6IHRlc3RQcmltaXRpdmUocm91dGUudXJpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVzdFByaW1pdGl2ZShyb3V0ZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gbWF0Y2ggYSByb3V0ZSBmcm9tIHRoZSBTREsgY29uZmlndXJhdGlvbiB0byB0aGUgSFRUUCByZXF1ZXN0LlxuICAgKiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgcm91dGUgY29uZmlndXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIEh0dHAgcmVxdWVzdFxuICAgKiBAcGFyYW0gY29uZmlnIEh0dHBJbnRlcmNlcHRvckNvbmZpZ1xuICAgKi9cbiAgcHJpdmF0ZSBmaW5kTWF0Y2hpbmdSb3V0ZShcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIGNvbmZpZzogSHR0cEludGVyY2VwdG9yQ29uZmlnXG4gICk6IE9ic2VydmFibGU8QXBpUm91dGVEZWZpbml0aW9uIHwgbnVsbD4ge1xuICAgIHJldHVybiBmcm9tKGNvbmZpZy5hbGxvd2VkTGlzdCkucGlwZShcbiAgICAgIGZpcnN0KChyb3V0ZSkgPT4gdGhpcy5jYW5BdHRhY2hUb2tlbihyb3V0ZSwgcmVxdWVzdCksIG51bGwpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYWxsb3dBbm9ueW1vdXMocm91dGU6IEFwaVJvdXRlRGVmaW5pdGlvbiB8IG51bGwsIGVycjogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICEhcm91dGUgJiZcbiAgICAgIGlzSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcocm91dGUpICYmXG4gICAgICAhIXJvdXRlLmFsbG93QW5vbnltb3VzICYmXG4gICAgICBbJ2xvZ2luX3JlcXVpcmVkJywgJ2NvbnNlbnRfcmVxdWlyZWQnLCAnbWlzc2luZ19yZWZyZXNoX3Rva2VuJ10uaW5jbHVkZXMoXG4gICAgICAgIGVyci5lcnJvclxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cbiJdfQ==