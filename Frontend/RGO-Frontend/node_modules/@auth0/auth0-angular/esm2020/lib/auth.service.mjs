import { Injectable, Inject } from '@angular/core';
import { of, from, Subject, iif, defer, ReplaySubject, throwError, } from 'rxjs';
import { concatMap, tap, map, takeUntil, catchError, switchMap, withLatestFrom, } from 'rxjs/operators';
import { Auth0ClientService } from './auth.client';
import * as i0 from "@angular/core";
import * as i1 from "./auth.config";
import * as i2 from "./abstract-navigator";
import * as i3 from "./auth.state";
import * as i4 from "@auth0/auth0-spa-js";
export class AuthService {
    constructor(auth0Client, configFactory, navigator, authState) {
        this.auth0Client = auth0Client;
        this.configFactory = configFactory;
        this.navigator = navigator;
        this.authState = authState;
        this.appStateSubject$ = new ReplaySubject(1);
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$ = new Subject();
        /**
         * Emits boolean values indicating the loading state of the SDK.
         */
        this.isLoading$ = this.authState.isLoading$;
        /**
         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.
         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.
         */
        this.isAuthenticated$ = this.authState.isAuthenticated$;
        /**
         * Emits details about the authenticated user, or null if not authenticated.
         */
        this.user$ = this.authState.user$;
        /**
         * Emits ID token claims when authenticated, or null if not authenticated.
         */
        this.idTokenClaims$ = this.authState.idTokenClaims$;
        /**
         * Emits errors that occur during login, or when checking for an active session on startup.
         */
        this.error$ = this.authState.error$;
        /**
         * Emits the value (if any) that was passed to the `loginWithRedirect` method call
         * but only **after** `handleRedirectCallback` is first called
         */
        this.appState$ = this.appStateSubject$.asObservable();
        const checkSessionOrCallback$ = (isCallback) => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));
        this.shouldHandleCallback()
            .pipe(switchMap((isCallback) => checkSessionOrCallback$(isCallback).pipe(catchError((error) => {
            const config = this.configFactory.get();
            this.navigator.navigateByUrl(config.errorPath || '/');
            this.authState.setError(error);
            return of(undefined);
        }))), tap(() => {
            this.authState.setIsLoading(false);
        }), takeUntil(this.ngUnsubscribe$))
            .subscribe();
    }
    /**
     * Called when the service is destroyed
     */
    ngOnDestroy() {
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
    /**
     * ```js
     * loginWithRedirect(options);
     * ```
     *
     * Performs a redirect to `/authorize` using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated.
     *
     * @param options The login options
     */
    loginWithRedirect(options) {
        return from(this.auth0Client.loginWithRedirect(options));
    }
    /**
     * ```js
     * await loginWithPopup(options);
     * ```
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     *
     * IMPORTANT: This method has to be called from an event handler
     * that was started by the user like a button click, for example,
     * otherwise the popup will be blocked in most browsers.
     *
     * @param options The login options
     * @param config Configuration for the popup window
     */
    loginWithPopup(options, config) {
        return from(this.auth0Client.loginWithPopup(options, config).then(() => {
            this.authState.refresh();
        }));
    }
    /**
     * ```js
     * logout();
     * ```
     *
     * Clears the application session and performs a redirect to `/v2/logout`, using
     * the parameters provided as arguments, to clear the Auth0 session.
     * If the `federated` option is specified it also clears the Identity Provider session.
     * If the `openUrl` option is set to false, it only clears the application session.
     * It is invalid to set both the `federated` to true and `openUrl` to `false`,
     * and an error will be thrown if you do.
     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).
     *
     * @param options The logout options
     */
    logout(options) {
        return from(this.auth0Client.logout(options).then(() => {
            if (options?.openUrl === false || options?.openUrl) {
                this.authState.refresh();
            }
        }));
    }
    /**
     * ```js
     * getAccessTokenSilently(options).subscribe(token => ...)
     * ```
     *
     * If there's a valid token stored, return it. Otherwise, opens an
     * iframe with the `/authorize` URL using the parameters provided
     * as arguments. Random and secure `state` and `nonce` parameters
     * will be auto-generated. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * If refresh tokens are used, the token endpoint is called directly with the
     * 'refresh_token' grant. If no refresh token is available to make this call,
     * the SDK falls back to using an iframe to the '/authorize' URL.
     *
     * This method may use a web worker to perform the token call if the in-memory
     * cache is used.
     *
     * If an `audience` value is given to this function, the SDK always falls
     * back to using an iframe to make the token exchange.
     *
     * Note that in all cases, falling back to an iframe requires access to
     * the `auth0` cookie, and thus will not work in browsers that block third-party
     * cookies by default (Safari, Brave, etc).
     *
     * @param options The options for configuring the token fetch.
     */
    getAccessTokenSilently(options = {}) {
        return of(this.auth0Client).pipe(concatMap((client) => options.detailedResponse === true
            ? client.getTokenSilently({ ...options, detailedResponse: true })
            : client.getTokenSilently(options)), tap((token) => {
            if (token) {
                this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token);
            }
        }), catchError((error) => {
            this.authState.setError(error);
            this.authState.refresh();
            return throwError(error);
        }));
    }
    /**
     * ```js
     * getTokenWithPopup(options).subscribe(token => ...)
     * ```
     *
     * Get an access token interactively.
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     */
    getAccessTokenWithPopup(options) {
        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenWithPopup(options)), tap((token) => {
            if (token) {
                this.authState.setAccessToken(token);
            }
        }), catchError((error) => {
            this.authState.setError(error);
            this.authState.refresh();
            return throwError(error);
        }));
    }
    /**
     * ```js
     * handleRedirectCallback(url).subscribe(result => ...)
     * ```
     *
     * After the browser redirects back to the callback page,
     * call `handleRedirectCallback` to handle success and error
     * responses from Auth0. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * Calling this method also refreshes the authentication and user states.
     *
     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.
     */
    handleRedirectCallback(url) {
        return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {
            if (!isLoading) {
                this.authState.refresh();
            }
            const appState = result?.appState;
            const target = appState?.target ?? '/';
            if (appState) {
                this.appStateSubject$.next(appState);
            }
            this.navigator.navigateByUrl(target);
        }), map(([result]) => result));
    }
    shouldHandleCallback() {
        return of(location.search).pipe(map((search) => {
            const searchParams = new URLSearchParams(search);
            return ((searchParams.has('code') || searchParams.has('error')) &&
                searchParams.has('state') &&
                !this.configFactory.get().skipRedirectCallback);
        }));
    }
}
AuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AuthService, deps: [{ token: Auth0ClientService }, { token: i1.AuthClientConfig }, { token: i2.AbstractNavigator }, { token: i3.AuthState }], target: i0.ɵɵFactoryTarget.Injectable });
AuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AuthService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: AuthService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i4.Auth0Client, decorators: [{
                    type: Inject,
                    args: [Auth0ClientService]
                }] }, { type: i1.AuthClientConfig }, { type: i2.AbstractNavigator }, { type: i3.AuthState }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvYXV0aDAtYW5ndWxhci9zcmMvbGliL2F1dGguc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBYSxNQUFNLGVBQWUsQ0FBQztBQVk5RCxPQUFPLEVBQ0wsRUFBRSxFQUNGLElBQUksRUFDSixPQUFPLEVBRVAsR0FBRyxFQUNILEtBQUssRUFDTCxhQUFhLEVBQ2IsVUFBVSxHQUNYLE1BQU0sTUFBTSxDQUFDO0FBRWQsT0FBTyxFQUNMLFNBQVMsRUFDVCxHQUFHLEVBQ0gsR0FBRyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsU0FBUyxFQUNULGNBQWMsR0FDZixNQUFNLGdCQUFnQixDQUFDO0FBRXhCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7O0FBU25ELE1BQU0sT0FBTyxXQUFXO0lBdUN0QixZQUNzQyxXQUF3QixFQUNwRCxhQUErQixFQUMvQixTQUE0QixFQUM1QixTQUFvQjtRQUhRLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3BELGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUMvQixjQUFTLEdBQVQsU0FBUyxDQUFtQjtRQUM1QixjQUFTLEdBQVQsU0FBUyxDQUFXO1FBeEN0QixxQkFBZ0IsR0FBRyxJQUFJLGFBQWEsQ0FBWSxDQUFDLENBQUMsQ0FBQztRQUUzRCx1Q0FBdUM7UUFDL0IsbUJBQWMsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO1FBQzdDOztXQUVHO1FBQ00sZUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDO1FBRWhEOzs7V0FHRztRQUNNLHFCQUFnQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUM7UUFFNUQ7O1dBRUc7UUFDTSxVQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxL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QUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNiLE1BQU0sWUFBWSxHQUFHLElBQUksZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pELE9BQU8sQ0FDTCxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDdkQsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUM7Z0JBQ3pCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FDL0MsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDOzt5R0F6U1UsV0FBVyxrQkF3Q1osa0JBQWtCOzZHQXhDakIsV0FBVyxjQUZWLE1BQU07NEZBRVAsV0FBVztrQkFIdkIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7OzBCQXlDSSxNQUFNOzJCQUFDLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIEF1dGgwQ2xpZW50LFxuICBQb3B1cExvZ2luT3B0aW9ucyxcbiAgUG9wdXBDb25maWdPcHRpb25zLFxuICBHZXRUb2tlblNpbGVudGx5T3B0aW9ucyxcbiAgR2V0VG9rZW5XaXRoUG9wdXBPcHRpb25zLFxuICBSZWRpcmVjdExvZ2luUmVzdWx0LFxuICBHZXRUb2tlblNpbGVudGx5VmVyYm9zZVJlc3BvbnNlLFxufSBmcm9tICdAYXV0aDAvYXV0aDAtc3BhLWpzJztcblxuaW1wb3J0IHtcbiAgb2YsXG4gIGZyb20sXG4gIFN1YmplY3QsXG4gIE9ic2VydmFibGUsXG4gIGlpZixcbiAgZGVmZXIsXG4gIFJlcGxheVN1YmplY3QsXG4gIHRocm93RXJyb3IsXG59IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQge1xuICBjb25jYXRNYXAsXG4gIHRhcCxcbiAgbWFwLFxuICB0YWtlVW50aWwsXG4gIGNhdGNoRXJyb3IsXG4gIHN3aXRjaE1hcCxcbiAgd2l0aExhdGVzdEZyb20sXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQXV0aDBDbGllbnRTZXJ2aWNlIH0gZnJvbSAnLi9hdXRoLmNsaWVudCc7XG5pbXBvcnQgeyBBYnN0cmFjdE5hdmlnYXRvciB9IGZyb20gJy4vYWJzdHJhY3QtbmF2aWdhdG9yJztcbmltcG9ydCB7IEF1dGhDbGllbnRDb25maWcsIEFwcFN0YXRlIH0gZnJvbSAnLi9hdXRoLmNvbmZpZyc7XG5pbXBvcnQgeyBBdXRoU3RhdGUgfSBmcm9tICcuL2F1dGguc3RhdGUnO1xuaW1wb3J0IHsgTG9nb3V0T3B0aW9ucywgUmVkaXJlY3RMb2dpbk9wdGlvbnMgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQXV0aFNlcnZpY2U8VEFwcFN0YXRlIGV4dGVuZHMgQXBwU3RhdGUgPSBBcHBTdGF0ZT5cbiAgaW1wbGVtZW50cyBPbkRlc3Ryb3lcbntcbiAgcHJpdmF0ZSBhcHBTdGF0ZVN1YmplY3QkID0gbmV3IFJlcGxheVN1YmplY3Q8VEFwcFN0YXRlPigxKTtcblxuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDExNzcxNjNcbiAgcHJpdmF0ZSBuZ1Vuc3Vic2NyaWJlJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIC8qKlxuICAgKiBFbWl0cyBib29sZWFuIHZhbHVlcyBpbmRpY2F0aW5nIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoZSBTREsuXG4gICAqL1xuICByZWFkb25seSBpc0xvYWRpbmckID0gdGhpcy5hdXRoU3RhdGUuaXNMb2FkaW5nJDtcblxuICAvKipcbiAgICogRW1pdHMgYm9vbGVhbiB2YWx1ZXMgaW5kaWNhdGluZyB0aGUgYXV0aGVudGljYXRpb24gc3RhdGUgb2YgdGhlIHVzZXIuIElmIGB0cnVlYCwgaXQgbWVhbnMgYSB1c2VyIGhhcyBhdXRoZW50aWNhdGVkLlxuICAgKiBUaGlzIGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIGBpc0xvYWRpbmckYCwgc28gdGhlcmUgaXMgbm8gbmVlZCB0byBtYW51YWxseSBjaGVjayB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgU0RLLlxuICAgKi9cbiAgcmVhZG9ubHkgaXNBdXRoZW50aWNhdGVkJCA9IHRoaXMuYXV0aFN0YXRlLmlzQXV0aGVudGljYXRlZCQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGRldGFpbHMgYWJvdXQgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlciwgb3IgbnVsbCBpZiBub3QgYXV0aGVudGljYXRlZC5cbiAgICovXG4gIHJlYWRvbmx5IHVzZXIkID0gdGhpcy5hdXRoU3RhdGUudXNlciQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIElEIHRva2VuIGNsYWltcyB3aGVuIGF1dGhlbnRpY2F0ZWQsIG9yIG51bGwgaWYgbm90IGF1dGhlbnRpY2F0ZWQuXG4gICAqL1xuICByZWFkb25seSBpZFRva2VuQ2xhaW1zJCA9IHRoaXMuYXV0aFN0YXRlLmlkVG9rZW5DbGFpbXMkO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgbG9naW4sIG9yIHdoZW4gY2hlY2tpbmcgZm9yIGFuIGFjdGl2ZSBzZXNzaW9uIG9uIHN0YXJ0dXAuXG4gICAqL1xuICByZWFkb25seSBlcnJvciQgPSB0aGlzLmF1dGhTdGF0ZS5lcnJvciQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSB2YWx1ZSAoaWYgYW55KSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGBsb2dpbldpdGhSZWRpcmVjdGAgbWV0aG9kIGNhbGxcbiAgICogYnV0IG9ubHkgKiphZnRlcioqIGBoYW5kbGVSZWRpcmVjdENhbGxiYWNrYCBpcyBmaXJzdCBjYWxsZWRcbiAgICovXG4gIHJlYWRvbmx5IGFwcFN0YXRlJCA9IHRoaXMuYXBwU3RhdGVTdWJqZWN0JC5hc09ic2VydmFibGUoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEF1dGgwQ2xpZW50U2VydmljZSkgcHJpdmF0ZSBhdXRoMENsaWVudDogQXV0aDBDbGllbnQsXG4gICAgcHJpdmF0ZSBjb25maWdGYWN0b3J5OiBBdXRoQ2xpZW50Q29uZmlnLFxuICAgIHByaXZhdGUgbmF2aWdhdG9yOiBBYnN0cmFjdE5hdmlnYXRvcixcbiAgICBwcml2YXRlIGF1dGhTdGF0ZTogQXV0aFN0YXRlXG4gICkge1xuICAgIGNvbnN0IGNoZWNrU2Vzc2lvbk9yQ2FsbGJhY2skID0gKGlzQ2FsbGJhY2s6IGJvb2xlYW4pID0+XG4gICAgICBpaWYoXG4gICAgICAgICgpID0+IGlzQ2FsbGJhY2ssXG4gICAgICAgIHRoaXMuaGFuZGxlUmVkaXJlY3RDYWxsYmFjaygpLFxuICAgICAgICBkZWZlcigoKSA9PiB0aGlzLmF1dGgwQ2xpZW50LmNoZWNrU2Vzc2lvbigpKVxuICAgICAgKTtcblxuICAgIHRoaXMuc2hvdWxkSGFuZGxlQ2FsbGJhY2soKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgoaXNDYWxsYmFjaykgPT5cbiAgICAgICAgICBjaGVja1Nlc3Npb25PckNhbGxiYWNrJChpc0NhbGxiYWNrKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWdGYWN0b3J5LmdldCgpO1xuICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRvci5uYXZpZ2F0ZUJ5VXJsKGNvbmZpZy5lcnJvclBhdGggfHwgJy8nKTtcbiAgICAgICAgICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYXV0aFN0YXRlLnNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH0pLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5uZ1Vuc3Vic2NyaWJlJClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgc2VydmljZSBpcyBkZXN0cm95ZWRcbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MTE3NzE2M1xuICAgIHRoaXMubmdVbnN1YnNjcmliZSQubmV4dCgpO1xuICAgIHRoaXMubmdVbnN1YnNjcmliZSQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBsb2dpbldpdGhSZWRpcmVjdChvcHRpb25zKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFBlcmZvcm1zIGEgcmVkaXJlY3QgdG8gYC9hdXRob3JpemVgIHVzaW5nIHRoZSBwYXJhbWV0ZXJzXG4gICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgKiBwYXJhbWV0ZXJzIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBsb2dpbiBvcHRpb25zXG4gICAqL1xuICBsb2dpbldpdGhSZWRpcmVjdChcbiAgICBvcHRpb25zPzogUmVkaXJlY3RMb2dpbk9wdGlvbnM8VEFwcFN0YXRlPlxuICApOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gZnJvbSh0aGlzLmF1dGgwQ2xpZW50LmxvZ2luV2l0aFJlZGlyZWN0KG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBhd2FpdCBsb2dpbldpdGhQb3B1cChvcHRpb25zKTtcbiAgICogYGBgXG4gICAqXG4gICAqIE9wZW5zIGEgcG9wdXAgd2l0aCB0aGUgYC9hdXRob3JpemVgIFVSTCB1c2luZyB0aGUgcGFyYW1ldGVyc1xuICAgKiBwcm92aWRlZCBhcyBhcmd1bWVudHMuIFJhbmRvbSBhbmQgc2VjdXJlIGBzdGF0ZWAgYW5kIGBub25jZWBcbiAgICogcGFyYW1ldGVycyB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLiBJZiB0aGUgcmVzcG9uc2UgaXMgc3VjY2Vzc2Z1bCxcbiAgICogcmVzdWx0cyB3aWxsIGJlIHZhbGlkIGFjY29yZGluZyB0byB0aGVpciBleHBpcmF0aW9uIHRpbWVzLlxuICAgKlxuICAgKiBJTVBPUlRBTlQ6IFRoaXMgbWV0aG9kIGhhcyB0byBiZSBjYWxsZWQgZnJvbSBhbiBldmVudCBoYW5kbGVyXG4gICAqIHRoYXQgd2FzIHN0YXJ0ZWQgYnkgdGhlIHVzZXIgbGlrZSBhIGJ1dHRvbiBjbGljaywgZm9yIGV4YW1wbGUsXG4gICAqIG90aGVyd2lzZSB0aGUgcG9wdXAgd2lsbCBiZSBibG9ja2VkIGluIG1vc3QgYnJvd3NlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBsb2dpbiBvcHRpb25zXG4gICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIHBvcHVwIHdpbmRvd1xuICAgKi9cbiAgbG9naW5XaXRoUG9wdXAoXG4gICAgb3B0aW9ucz86IFBvcHVwTG9naW5PcHRpb25zLFxuICAgIGNvbmZpZz86IFBvcHVwQ29uZmlnT3B0aW9uc1xuICApOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gZnJvbShcbiAgICAgIHRoaXMuYXV0aDBDbGllbnQubG9naW5XaXRoUG9wdXAob3B0aW9ucywgY29uZmlnKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGxvZ291dCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQ2xlYXJzIHRoZSBhcHBsaWNhdGlvbiBzZXNzaW9uIGFuZCBwZXJmb3JtcyBhIHJlZGlyZWN0IHRvIGAvdjIvbG9nb3V0YCwgdXNpbmdcbiAgICogdGhlIHBhcmFtZXRlcnMgcHJvdmlkZWQgYXMgYXJndW1lbnRzLCB0byBjbGVhciB0aGUgQXV0aDAgc2Vzc2lvbi5cbiAgICogSWYgdGhlIGBmZWRlcmF0ZWRgIG9wdGlvbiBpcyBzcGVjaWZpZWQgaXQgYWxzbyBjbGVhcnMgdGhlIElkZW50aXR5IFByb3ZpZGVyIHNlc3Npb24uXG4gICAqIElmIHRoZSBgb3BlblVybGAgb3B0aW9uIGlzIHNldCB0byBmYWxzZSwgaXQgb25seSBjbGVhcnMgdGhlIGFwcGxpY2F0aW9uIHNlc3Npb24uXG4gICAqIEl0IGlzIGludmFsaWQgdG8gc2V0IGJvdGggdGhlIGBmZWRlcmF0ZWRgIHRvIHRydWUgYW5kIGBvcGVuVXJsYCB0byBgZmFsc2VgLFxuICAgKiBhbmQgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgeW91IGRvLlxuICAgKiBbUmVhZCBtb3JlIGFib3V0IGhvdyBMb2dvdXQgd29ya3MgYXQgQXV0aDBdKGh0dHBzOi8vYXV0aDAuY29tL2RvY3MvbG9nb3V0KS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGxvZ291dCBvcHRpb25zXG4gICAqL1xuICBsb2dvdXQob3B0aW9ucz86IExvZ291dE9wdGlvbnMpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gZnJvbShcbiAgICAgIHRoaXMuYXV0aDBDbGllbnQubG9nb3V0KG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucz8ub3BlblVybCA9PT0gZmFsc2UgfHwgb3B0aW9ucz8ub3BlblVybCkge1xuICAgICAgICAgIHRoaXMuYXV0aFN0YXRlLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYSBuZXcgYWNjZXNzIHRva2VuIGFuZCByZXR1cm5zIHRoZSByZXNwb25zZSBmcm9tIHRoZSAvb2F1dGgvdG9rZW4gZW5kcG9pbnQsIG9taXR0aW5nIHRoZSByZWZyZXNoIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIHRva2VuIGZldGNoLlxuICAgKi9cbiAgZ2V0QWNjZXNzVG9rZW5TaWxlbnRseShcbiAgICBvcHRpb25zOiBHZXRUb2tlblNpbGVudGx5T3B0aW9ucyAmIHsgZGV0YWlsZWRSZXNwb25zZTogdHJ1ZSB9XG4gICk6IE9ic2VydmFibGU8R2V0VG9rZW5TaWxlbnRseVZlcmJvc2VSZXNwb25zZT47XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYSBuZXcgYWNjZXNzIHRva2VuIGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIHRva2VuIGZldGNoLlxuICAgKi9cbiAgZ2V0QWNjZXNzVG9rZW5TaWxlbnRseShvcHRpb25zPzogR2V0VG9rZW5TaWxlbnRseU9wdGlvbnMpOiBPYnNlcnZhYmxlPHN0cmluZz47XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGdldEFjY2Vzc1Rva2VuU2lsZW50bHkob3B0aW9ucykuc3Vic2NyaWJlKHRva2VuID0+IC4uLilcbiAgICogYGBgXG4gICAqXG4gICAqIElmIHRoZXJlJ3MgYSB2YWxpZCB0b2tlbiBzdG9yZWQsIHJldHVybiBpdC4gT3RoZXJ3aXNlLCBvcGVucyBhblxuICAgKiBpZnJhbWUgd2l0aCB0aGUgYC9hdXRob3JpemVgIFVSTCB1c2luZyB0aGUgcGFyYW1ldGVycyBwcm92aWRlZFxuICAgKiBhcyBhcmd1bWVudHMuIFJhbmRvbSBhbmQgc2VjdXJlIGBzdGF0ZWAgYW5kIGBub25jZWAgcGFyYW1ldGVyc1xuICAgKiB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLiBJZiB0aGUgcmVzcG9uc2UgaXMgc3VjY2Vzc2Z1bCwgcmVzdWx0c1xuICAgKiB3aWxsIGJlIHZhbGlkIGFjY29yZGluZyB0byB0aGVpciBleHBpcmF0aW9uIHRpbWVzLlxuICAgKlxuICAgKiBJZiByZWZyZXNoIHRva2VucyBhcmUgdXNlZCwgdGhlIHRva2VuIGVuZHBvaW50IGlzIGNhbGxlZCBkaXJlY3RseSB3aXRoIHRoZVxuICAgKiAncmVmcmVzaF90b2tlbicgZ3JhbnQuIElmIG5vIHJlZnJlc2ggdG9rZW4gaXMgYXZhaWxhYmxlIHRvIG1ha2UgdGhpcyBjYWxsLFxuICAgKiB0aGUgU0RLIGZhbGxzIGJhY2sgdG8gdXNpbmcgYW4gaWZyYW1lIHRvIHRoZSAnL2F1dGhvcml6ZScgVVJMLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBtYXkgdXNlIGEgd2ViIHdvcmtlciB0byBwZXJmb3JtIHRoZSB0b2tlbiBjYWxsIGlmIHRoZSBpbi1tZW1vcnlcbiAgICogY2FjaGUgaXMgdXNlZC5cbiAgICpcbiAgICogSWYgYW4gYGF1ZGllbmNlYCB2YWx1ZSBpcyBnaXZlbiB0byB0aGlzIGZ1bmN0aW9uLCB0aGUgU0RLIGFsd2F5cyBmYWxsc1xuICAgKiBiYWNrIHRvIHVzaW5nIGFuIGlmcmFtZSB0byBtYWtlIHRoZSB0b2tlbiBleGNoYW5nZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IGluIGFsbCBjYXNlcywgZmFsbGluZyBiYWNrIHRvIGFuIGlmcmFtZSByZXF1aXJlcyBhY2Nlc3MgdG9cbiAgICogdGhlIGBhdXRoMGAgY29va2llLCBhbmQgdGh1cyB3aWxsIG5vdCB3b3JrIGluIGJyb3dzZXJzIHRoYXQgYmxvY2sgdGhpcmQtcGFydHlcbiAgICogY29va2llcyBieSBkZWZhdWx0IChTYWZhcmksIEJyYXZlLCBldGMpLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIHRva2VuIGZldGNoLlxuICAgKi9cbiAgZ2V0QWNjZXNzVG9rZW5TaWxlbnRseShcbiAgICBvcHRpb25zOiBHZXRUb2tlblNpbGVudGx5T3B0aW9ucyA9IHt9XG4gICk6IE9ic2VydmFibGU8c3RyaW5nIHwgR2V0VG9rZW5TaWxlbnRseVZlcmJvc2VSZXNwb25zZT4ge1xuICAgIHJldHVybiBvZih0aGlzLmF1dGgwQ2xpZW50KS5waXBlKFxuICAgICAgY29uY2F0TWFwKChjbGllbnQpID0+XG4gICAgICAgIG9wdGlvbnMuZGV0YWlsZWRSZXNwb25zZSA9PT0gdHJ1ZVxuICAgICAgICAgID8gY2xpZW50LmdldFRva2VuU2lsZW50bHkoeyAuLi5vcHRpb25zLCBkZXRhaWxlZFJlc3BvbnNlOiB0cnVlIH0pXG4gICAgICAgICAgOiBjbGllbnQuZ2V0VG9rZW5TaWxlbnRseShvcHRpb25zKVxuICAgICAgKSxcbiAgICAgIHRhcCgodG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0QWNjZXNzVG9rZW4oXG4gICAgICAgICAgICB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnID8gdG9rZW4gOiB0b2tlbi5hY2Nlc3NfdG9rZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnNldEVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogYGBganNcbiAgICogZ2V0VG9rZW5XaXRoUG9wdXAob3B0aW9ucykuc3Vic2NyaWJlKHRva2VuID0+IC4uLilcbiAgICogYGBgXG4gICAqXG4gICAqIEdldCBhbiBhY2Nlc3MgdG9rZW4gaW50ZXJhY3RpdmVseS5cbiAgICpcbiAgICogT3BlbnMgYSBwb3B1cCB3aXRoIHRoZSBgL2F1dGhvcml6ZWAgVVJMIHVzaW5nIHRoZSBwYXJhbWV0ZXJzXG4gICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgKiBwYXJhbWV0ZXJzIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuIElmIHRoZSByZXNwb25zZSBpcyBzdWNjZXNzZnVsLFxuICAgKiByZXN1bHRzIHdpbGwgYmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAqL1xuICBnZXRBY2Nlc3NUb2tlbldpdGhQb3B1cChcbiAgICBvcHRpb25zPzogR2V0VG9rZW5XaXRoUG9wdXBPcHRpb25zXG4gICk6IE9ic2VydmFibGU8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIG9mKHRoaXMuYXV0aDBDbGllbnQpLnBpcGUoXG4gICAgICBjb25jYXRNYXAoKGNsaWVudCkgPT4gY2xpZW50LmdldFRva2VuV2l0aFBvcHVwKG9wdGlvbnMpKSxcbiAgICAgIHRhcCgodG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0QWNjZXNzVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnNldEVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogYGBganNcbiAgICogaGFuZGxlUmVkaXJlY3RDYWxsYmFjayh1cmwpLnN1YnNjcmliZShyZXN1bHQgPT4gLi4uKVxuICAgKiBgYGBcbiAgICpcbiAgICogQWZ0ZXIgdGhlIGJyb3dzZXIgcmVkaXJlY3RzIGJhY2sgdG8gdGhlIGNhbGxiYWNrIHBhZ2UsXG4gICAqIGNhbGwgYGhhbmRsZVJlZGlyZWN0Q2FsbGJhY2tgIHRvIGhhbmRsZSBzdWNjZXNzIGFuZCBlcnJvclxuICAgKiByZXNwb25zZXMgZnJvbSBBdXRoMC4gSWYgdGhlIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWwsIHJlc3VsdHNcbiAgICogd2lsbCBiZSB2YWxpZCBhY2NvcmRpbmcgdG8gdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cbiAgICpcbiAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCBhbHNvIHJlZnJlc2hlcyB0aGUgYXV0aGVudGljYXRpb24gYW5kIHVzZXIgc3RhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgYHN0YXRlYCBhbmQgYGNvZGVgIHZhbHVlcy4gRGVmYXVsdHMgdG8gYHdpbmRvdy5sb2NhdGlvbi5ocmVmYCBpZiBub3QgZ2l2ZW4uXG4gICAqL1xuICBoYW5kbGVSZWRpcmVjdENhbGxiYWNrKFxuICAgIHVybD86IHN0cmluZ1xuICApOiBPYnNlcnZhYmxlPFJlZGlyZWN0TG9naW5SZXN1bHQ8VEFwcFN0YXRlPj4ge1xuICAgIHJldHVybiBkZWZlcigoKSA9PlxuICAgICAgdGhpcy5hdXRoMENsaWVudC5oYW5kbGVSZWRpcmVjdENhbGxiYWNrPFRBcHBTdGF0ZT4odXJsKVxuICAgICkucGlwZShcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuYXV0aFN0YXRlLmlzTG9hZGluZyQpLFxuICAgICAgdGFwKChbcmVzdWx0LCBpc0xvYWRpbmddKSA9PiB7XG4gICAgICAgIGlmICghaXNMb2FkaW5nKSB7XG4gICAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcFN0YXRlID0gcmVzdWx0Py5hcHBTdGF0ZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXBwU3RhdGU/LnRhcmdldCA/PyAnLyc7XG5cbiAgICAgICAgaWYgKGFwcFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5hcHBTdGF0ZVN1YmplY3QkLm5leHQoYXBwU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0b3IubmF2aWdhdGVCeVVybCh0YXJnZXQpO1xuICAgICAgfSksXG4gICAgICBtYXAoKFtyZXN1bHRdKSA9PiByZXN1bHQpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvdWxkSGFuZGxlQ2FsbGJhY2soKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIG9mKGxvY2F0aW9uLnNlYXJjaCkucGlwZShcbiAgICAgIG1hcCgoc2VhcmNoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2VhcmNoUGFyYW1zLmhhcygnY29kZScpIHx8IHNlYXJjaFBhcmFtcy5oYXMoJ2Vycm9yJykpICYmXG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmhhcygnc3RhdGUnKSAmJlxuICAgICAgICAgICF0aGlzLmNvbmZpZ0ZhY3RvcnkuZ2V0KCkuc2tpcFJlZGlyZWN0Q2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIl19