import { Component, ElementRef, EventEmitter, Input, Output, } from "@angular/core";
import { BarChart, LineChart, PieChart, } from "chartist";
import * as i0 from "@angular/core";
/**
 * Angular component which renders Chartist chart.
 *
 * See Chartist {@link https://gionkunz.github.io/chartist-js/api-documentation.html API documentation} and
 * {@link https://gionkunz.github.io/chartist-js/examples.html examples} for more information.
 * ### Example
 ```html
 <x-chartist
   [configuration]="configuration"
   [events]="events"
 ></x-chartist>
 ```
 */
export class ChartistComponent {
    elementRef;
    configuration;
    /**
     * Events object where keys are Chartist event names and values are event handler functions.
     *
     * Supported events are: draw, optionsChanged, data, animationBegin, animationEnd, created.
     *
     * Event handler function will receive a data argument which contains event data.
     */
    events;
    /**
     * Event emitted after Chartist chart has been initialized.
     *
     * Event handler function will receive chart instance argument.
     */
    initialized = new EventEmitter();
    chart;
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    ngOnInit() {
        if (this.configuration.type && this.configuration.data) {
            this.renderChart();
        }
    }
    ngOnChanges(changes) {
        this.update(changes);
    }
    ngOnDestroy() {
        if (this.chart) {
            this.chart.detach();
            this.chart = null;
        }
    }
    renderChart() {
        const nativeElement = this.elementRef.nativeElement;
        const { type, data, options, responsiveOptions } = this.configuration;
        if (type === "Bar") {
            this.chart = new BarChart(nativeElement, data, options, responsiveOptions);
        }
        else if (type === "Line") {
            this.chart = new LineChart(nativeElement, data, options, responsiveOptions);
        }
        else if (type === "Pie") {
            this.chart = new PieChart(nativeElement, data, options, responsiveOptions);
        }
        else {
            throw new Error(`${type} is not a known chart type`);
        }
        if (this.events) {
            this.bindEvents();
        }
        this.initialized.emit(this.chart);
    }
    update(changes) {
        const { type, data, options } = this.configuration;
        if (!type || !data) {
            return;
        }
        const changedConfiguration = changes.configuration
            .currentValue;
        if (!this.chart || changedConfiguration.type !== type) {
            this.renderChart();
        }
        else if ("data" in changedConfiguration ||
            "options" in changedConfiguration) {
            this.chart.update(data, options);
        }
    }
    bindEvents() {
        for (const event of Object.keys(this.events)) {
            this.chart.on(event, this.events[event]);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.1", ngImport: i0, type: ChartistComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.1", type: ChartistComponent, selector: "x-chartist", inputs: { configuration: "configuration", events: "events" }, outputs: { initialized: "initialized" }, usesOnChanges: true, ngImport: i0, template: "", isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.1", ngImport: i0, type: ChartistComponent, decorators: [{
            type: Component,
            args: [{ selector: "x-chartist", template: "", styles: [":host{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { configuration: [{
                type: Input
            }], events: [{
                type: Input
            }], initialized: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRpc3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctY2hhcnRpc3Qvc3JjL2xpYi9jaGFydGlzdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFJTCxNQUFNLEdBRVAsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLFFBQVEsRUFHUixTQUFTLEVBR1QsUUFBUSxHQUlULE1BQU0sVUFBVSxDQUFDOztBQXFDbEI7Ozs7Ozs7Ozs7OztHQVlHO0FBWUgsTUFBTSxPQUFPLGlCQUFpQjtJQXdCUjtJQXRCcEIsYUFBYSxDQUFnQjtJQUU3Qjs7Ozs7O09BTUc7SUFFSCxNQUFNLENBQWE7SUFFbkI7Ozs7T0FJRztJQUVILFdBQVcsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO0lBRTdDLEtBQUssQ0FBYTtJQUVsQixZQUFvQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO0lBQUcsQ0FBQztJQUU5QyxRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRTtZQUN0RCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDcEI7SUFDSCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDZCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1NBQ25CO0lBQ0gsQ0FBQztJQUVELFdBQVc7UUFDVCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztRQUNwRCxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBRXRFLElBQUksSUFBSSxLQUFLLEtBQUssRUFBRTtZQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksUUFBUSxDQUN2QixhQUFhLEVBQ2IsSUFBSSxFQUNKLE9BQU8sRUFDUCxpQkFBaUIsQ0FDbEIsQ0FBQztTQUNIO2FBQU0sSUFBSSxJQUFJLEtBQUssTUFBTSxFQUFFO1lBQzFCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxTQUFTLENBQ3hCLGFBQWEsRUFDYixJQUFJLEVBQ0osT0FBTyxFQUNQLGlCQUFpQixDQUNsQixDQUFDO1NBQ0g7YUFBTSxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUU7WUFDekIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFFBQVEsQ0FDdkIsYUFBYSxFQUNiLElBQUksRUFDSixPQUFPLEVBQ1AsaUJBQWlCLENBQ2xCLENBQUM7U0FDSDthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksNEJBQTRCLENBQUMsQ0FBQztTQUN0RDtRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUNuQjtRQUVELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsTUFBTSxDQUFDLE9BQXNCO1FBQzNCLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7UUFFbkQsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNsQixPQUFPO1NBQ1I7UUFFRCxNQUFNLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxhQUFhO2FBQy9DLFlBQTZCLENBQUM7UUFFakMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksb0JBQW9CLENBQUMsSUFBSSxLQUFLLElBQUksRUFBRTtZQUNyRCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDcEI7YUFBTSxJQUNMLE1BQU0sSUFBSSxvQkFBb0I7WUFDOUIsU0FBUyxJQUFJLG9CQUFvQixFQUNqQztZQUNBLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNsQztJQUNILENBQUM7SUFFRCxVQUFVO1FBQ1IsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM1QyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQzFDO0lBQ0gsQ0FBQzt1R0F2R1UsaUJBQWlCOzJGQUFqQixpQkFBaUIsOEtBVGxCLEVBQUU7OzJGQVNELGlCQUFpQjtrQkFYN0IsU0FBUzsrQkFDRSxZQUFZLFlBQ1osRUFBRTtpR0FXWixhQUFhO3NCQURaLEtBQUs7Z0JBV04sTUFBTTtzQkFETCxLQUFLO2dCQVNOLFdBQVc7c0JBRFYsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHtcbiAgQmFyQ2hhcnQsXG4gIEJhckNoYXJ0RGF0YSxcbiAgQmFyQ2hhcnRPcHRpb25zLFxuICBMaW5lQ2hhcnQsXG4gIExpbmVDaGFydERhdGEsXG4gIExpbmVDaGFydE9wdGlvbnMsXG4gIFBpZUNoYXJ0LFxuICBQaWVDaGFydERhdGEsXG4gIFBpZUNoYXJ0T3B0aW9ucyxcbiAgUmVzcG9uc2l2ZU9wdGlvbnMsXG59IGZyb20gXCJjaGFydGlzdFwiO1xuXG50eXBlIENoYXJ0VHlwZXMgPSBCYXJDaGFydCB8IExpbmVDaGFydCB8IFBpZUNoYXJ0O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhckNoYXJ0Q29uZmlndXJhdGlvbiB7XG4gIHR5cGU6IFwiQmFyXCI7XG4gIGRhdGE6IEJhckNoYXJ0RGF0YTtcbiAgb3B0aW9ucz86IEJhckNoYXJ0T3B0aW9ucztcbiAgcmVzcG9uc2l2ZU9wdGlvbnM/OiBSZXNwb25zaXZlT3B0aW9uczxCYXJDaGFydE9wdGlvbnM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVDaGFydENvbmZpZ3VyYXRpb24ge1xuICB0eXBlOiBcIkxpbmVcIjtcbiAgZGF0YTogTGluZUNoYXJ0RGF0YTtcbiAgb3B0aW9ucz86IExpbmVDaGFydE9wdGlvbnM7XG4gIHJlc3BvbnNpdmVPcHRpb25zPzogUmVzcG9uc2l2ZU9wdGlvbnM8TGluZUNoYXJ0T3B0aW9ucz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGllQ2hhcnRDb25maWd1cmF0aW9uIHtcbiAgdHlwZTogXCJQaWVcIjtcbiAgZGF0YTogUGllQ2hhcnREYXRhO1xuICBvcHRpb25zPzogUGllQ2hhcnRPcHRpb25zO1xuICByZXNwb25zaXZlT3B0aW9ucz86IFJlc3BvbnNpdmVPcHRpb25zPFBpZUNoYXJ0T3B0aW9ucz47XG59XG5cbmV4cG9ydCB0eXBlIENvbmZpZ3VyYXRpb24gPVxuICB8IEJhckNoYXJ0Q29uZmlndXJhdGlvblxuICB8IExpbmVDaGFydENvbmZpZ3VyYXRpb25cbiAgfCBQaWVDaGFydENvbmZpZ3VyYXRpb247XG5cbi8qKlxuICogUmVwcmVzZW50cyBjaGFydCBldmVudHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcnRFdmVudCB7XG4gIFtldmVudE5hbWU6IHN0cmluZ106IChkYXRhOiB1bmtub3duKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEFuZ3VsYXIgY29tcG9uZW50IHdoaWNoIHJlbmRlcnMgQ2hhcnRpc3QgY2hhcnQuXG4gKlxuICogU2VlIENoYXJ0aXN0IHtAbGluayBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9hcGktZG9jdW1lbnRhdGlvbi5odG1sIEFQSSBkb2N1bWVudGF0aW9ufSBhbmRcbiAqIHtAbGluayBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9leGFtcGxlcy5odG1sIGV4YW1wbGVzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqICMjIyBFeGFtcGxlXG4gYGBgaHRtbFxuIDx4LWNoYXJ0aXN0XG4gICBbY29uZmlndXJhdGlvbl09XCJjb25maWd1cmF0aW9uXCJcbiAgIFtldmVudHNdPVwiZXZlbnRzXCJcbiA+PC94LWNoYXJ0aXN0PlxuIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwieC1jaGFydGlzdFwiLFxuICB0ZW1wbGF0ZTogXCJcIixcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICBgLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDaGFydGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKVxuICBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBFdmVudHMgb2JqZWN0IHdoZXJlIGtleXMgYXJlIENoYXJ0aXN0IGV2ZW50IG5hbWVzIGFuZCB2YWx1ZXMgYXJlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBTdXBwb3J0ZWQgZXZlbnRzIGFyZTogZHJhdywgb3B0aW9uc0NoYW5nZWQsIGRhdGEsIGFuaW1hdGlvbkJlZ2luLCBhbmltYXRpb25FbmQsIGNyZWF0ZWQuXG4gICAqXG4gICAqIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGEgZGF0YSBhcmd1bWVudCB3aGljaCBjb250YWlucyBldmVudCBkYXRhLlxuICAgKi9cbiAgQElucHV0KClcbiAgZXZlbnRzOiBDaGFydEV2ZW50O1xuXG4gIC8qKlxuICAgKiBFdmVudCBlbWl0dGVkIGFmdGVyIENoYXJ0aXN0IGNoYXJ0IGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgKlxuICAgKiBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBjaGFydCBpbnN0YW5jZSBhcmd1bWVudC5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBpbml0aWFsaXplZCA9IG5ldyBFdmVudEVtaXR0ZXI8Q2hhcnRUeXBlcz4oKTtcblxuICBjaGFydDogQ2hhcnRUeXBlcztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi50eXBlICYmIHRoaXMuY29uZmlndXJhdGlvbi5kYXRhKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlKGNoYW5nZXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgIHRoaXMuY2hhcnQuZGV0YWNoKCk7XG4gICAgICB0aGlzLmNoYXJ0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZW5kZXJDaGFydCgpIHtcbiAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgeyB0eXBlLCBkYXRhLCBvcHRpb25zLCByZXNwb25zaXZlT3B0aW9ucyB9ID0gdGhpcy5jb25maWd1cmF0aW9uO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiQmFyXCIpIHtcbiAgICAgIHRoaXMuY2hhcnQgPSBuZXcgQmFyQ2hhcnQoXG4gICAgICAgIG5hdGl2ZUVsZW1lbnQsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJlc3BvbnNpdmVPcHRpb25zLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiTGluZVwiKSB7XG4gICAgICB0aGlzLmNoYXJ0ID0gbmV3IExpbmVDaGFydChcbiAgICAgICAgbmF0aXZlRWxlbWVudCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmVzcG9uc2l2ZU9wdGlvbnMsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJQaWVcIikge1xuICAgICAgdGhpcy5jaGFydCA9IG5ldyBQaWVDaGFydChcbiAgICAgICAgbmF0aXZlRWxlbWVudCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmVzcG9uc2l2ZU9wdGlvbnMsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZX0gaXMgbm90IGEga25vd24gY2hhcnQgdHlwZWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV2ZW50cykge1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZC5lbWl0KHRoaXMuY2hhcnQpO1xuICB9XG5cbiAgdXBkYXRlKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBjb25zdCB7IHR5cGUsIGRhdGEsIG9wdGlvbnMgfSA9IHRoaXMuY29uZmlndXJhdGlvbjtcblxuICAgIGlmICghdHlwZSB8fCAhZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWRDb25maWd1cmF0aW9uID0gY2hhbmdlcy5jb25maWd1cmF0aW9uXG4gICAgICAuY3VycmVudFZhbHVlIGFzIENvbmZpZ3VyYXRpb247XG5cbiAgICBpZiAoIXRoaXMuY2hhcnQgfHwgY2hhbmdlZENvbmZpZ3VyYXRpb24udHlwZSAhPT0gdHlwZSkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCgpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBcImRhdGFcIiBpbiBjaGFuZ2VkQ29uZmlndXJhdGlvbiB8fFxuICAgICAgXCJvcHRpb25zXCIgaW4gY2hhbmdlZENvbmZpZ3VyYXRpb25cbiAgICApIHtcbiAgICAgIHRoaXMuY2hhcnQudXBkYXRlKGRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGJpbmRFdmVudHMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykpIHtcbiAgICAgIHRoaXMuY2hhcnQub24oZXZlbnQsIHRoaXMuZXZlbnRzW2V2ZW50XSk7XG4gICAgfVxuICB9XG59XG4iXX0=