{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/HP/Desktop/GOP/RGO-Client/Frontend/RGO-Frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction e(e, t) {\n  var i = {};\n  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (i[o] = e[o]);\n  if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n    var n = 0;\n    for (o = Object.getOwnPropertySymbols(e); n < o.length; n++) t.indexOf(o[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[n]) && (i[o[n]] = e[o[n]]);\n  }\n  return i;\n}\nvar t = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction i(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nfunction o(e, t) {\n  return e(t = {\n    exports: {}\n  }, t.exports), t.exports;\n}\nvar n = o(function (e, t) {\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n  var i = function () {\n    function e() {\n      var e = this;\n      this.locked = new Map(), this.addToLocked = function (t, i) {\n        var o = e.locked.get(t);\n        void 0 === o ? void 0 === i ? e.locked.set(t, []) : e.locked.set(t, [i]) : void 0 !== i && (o.unshift(i), e.locked.set(t, o));\n      }, this.isLocked = function (t) {\n        return e.locked.has(t);\n      }, this.lock = function (t) {\n        return new Promise(function (i, o) {\n          e.isLocked(t) ? e.addToLocked(t, i) : (e.addToLocked(t), i());\n        });\n      }, this.unlock = function (t) {\n        var i = e.locked.get(t);\n        if (void 0 !== i && 0 !== i.length) {\n          var o = i.pop();\n          e.locked.set(t, i), void 0 !== o && setTimeout(o, 0);\n        } else e.locked.delete(t);\n      };\n    }\n    return e.getInstance = function () {\n      return void 0 === e.instance && (e.instance = new e()), e.instance;\n    }, e;\n  }();\n  t.default = function () {\n    return i.getInstance();\n  };\n});\ni(n);\nvar a = i(o(function (e, i) {\n  var o = t && t.__awaiter || function (e, t, i, o) {\n      return new (i || (i = Promise))(function (n, a) {\n        function s(e) {\n          try {\n            c(o.next(e));\n          } catch (e) {\n            a(e);\n          }\n        }\n        function r(e) {\n          try {\n            c(o.throw(e));\n          } catch (e) {\n            a(e);\n          }\n        }\n        function c(e) {\n          e.done ? n(e.value) : new i(function (t) {\n            t(e.value);\n          }).then(s, r);\n        }\n        c((o = o.apply(e, t || [])).next());\n      });\n    },\n    a = t && t.__generator || function (e, t) {\n      var i,\n        o,\n        n,\n        a,\n        s = {\n          label: 0,\n          sent: function () {\n            if (1 & n[0]) throw n[1];\n            return n[1];\n          },\n          trys: [],\n          ops: []\n        };\n      return a = {\n        next: r(0),\n        throw: r(1),\n        return: r(2)\n      }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function () {\n        return this;\n      }), a;\n      function r(a) {\n        return function (r) {\n          return function (a) {\n            if (i) throw new TypeError(\"Generator is already executing.\");\n            for (; s;) try {\n              if (i = 1, o && (n = 2 & a[0] ? o.return : a[0] ? o.throw || ((n = o.return) && n.call(o), 0) : o.next) && !(n = n.call(o, a[1])).done) return n;\n              switch (o = 0, n && (a = [2 & a[0], n.value]), a[0]) {\n                case 0:\n                case 1:\n                  n = a;\n                  break;\n                case 4:\n                  return s.label++, {\n                    value: a[1],\n                    done: !1\n                  };\n                case 5:\n                  s.label++, o = a[1], a = [0];\n                  continue;\n                case 7:\n                  a = s.ops.pop(), s.trys.pop();\n                  continue;\n                default:\n                  if (!(n = s.trys, (n = n.length > 0 && n[n.length - 1]) || 6 !== a[0] && 2 !== a[0])) {\n                    s = 0;\n                    continue;\n                  }\n                  if (3 === a[0] && (!n || a[1] > n[0] && a[1] < n[3])) {\n                    s.label = a[1];\n                    break;\n                  }\n                  if (6 === a[0] && s.label < n[1]) {\n                    s.label = n[1], n = a;\n                    break;\n                  }\n                  if (n && s.label < n[2]) {\n                    s.label = n[2], s.ops.push(a);\n                    break;\n                  }\n                  n[2] && s.ops.pop(), s.trys.pop();\n                  continue;\n              }\n              a = t.call(e, s);\n            } catch (e) {\n              a = [6, e], o = 0;\n            } finally {\n              i = n = 0;\n            }\n            if (5 & a[0]) throw a[1];\n            return {\n              value: a[0] ? a[1] : void 0,\n              done: !0\n            };\n          }([a, r]);\n        };\n      }\n    };\n  Object.defineProperty(i, \"__esModule\", {\n    value: !0\n  });\n  var s = \"browser-tabs-lock-key\";\n  function r(e) {\n    return new Promise(function (t) {\n      return setTimeout(t, e);\n    });\n  }\n  function c(e) {\n    for (var t = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\", i = \"\", o = 0; o < e; o++) {\n      i += t[Math.floor(Math.random() * t.length)];\n    }\n    return i;\n  }\n  var d = function () {\n    function e() {\n      this.acquiredIatSet = new Set(), this.id = Date.now().toString() + c(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), void 0 === e.waiters && (e.waiters = []);\n    }\n    return e.prototype.acquireLock = function (t, i) {\n      return void 0 === i && (i = 5e3), o(this, void 0, void 0, function () {\n        var o, n, d, u, l, h;\n        return a(this, function (a) {\n          switch (a.label) {\n            case 0:\n              o = Date.now() + c(4), n = Date.now() + i, d = s + \"-\" + t, u = window.localStorage, a.label = 1;\n            case 1:\n              return Date.now() < n ? [4, r(30)] : [3, 8];\n            case 2:\n              return a.sent(), null !== u.getItem(d) ? [3, 5] : (l = this.id + \"-\" + t + \"-\" + o, [4, r(Math.floor(25 * Math.random()))]);\n            case 3:\n              return a.sent(), u.setItem(d, JSON.stringify({\n                id: this.id,\n                iat: o,\n                timeoutKey: l,\n                timeAcquired: Date.now(),\n                timeRefreshed: Date.now()\n              })), [4, r(30)];\n            case 4:\n              return a.sent(), null !== (h = u.getItem(d)) && (h = JSON.parse(h)).id === this.id && h.iat === o ? (this.acquiredIatSet.add(o), this.refreshLockWhileAcquired(d, o), [2, !0]) : [3, 7];\n            case 5:\n              return e.lockCorrector(), [4, this.waitForSomethingToChange(n)];\n            case 6:\n              a.sent(), a.label = 7;\n            case 7:\n              return o = Date.now() + c(4), [3, 1];\n            case 8:\n              return [2, !1];\n          }\n        });\n      });\n    }, e.prototype.refreshLockWhileAcquired = function (e, t) {\n      return o(this, void 0, void 0, function () {\n        var i = this;\n        return a(this, function (s) {\n          return setTimeout(function () {\n            return o(i, void 0, void 0, function () {\n              var i, o;\n              return a(this, function (a) {\n                switch (a.label) {\n                  case 0:\n                    return [4, n.default().lock(t)];\n                  case 1:\n                    return a.sent(), this.acquiredIatSet.has(t) ? (i = window.localStorage, null === (o = i.getItem(e)) ? (n.default().unlock(t), [2]) : ((o = JSON.parse(o)).timeRefreshed = Date.now(), i.setItem(e, JSON.stringify(o)), n.default().unlock(t), this.refreshLockWhileAcquired(e, t), [2])) : (n.default().unlock(t), [2]);\n                }\n              });\n            });\n          }, 1e3), [2];\n        });\n      });\n    }, e.prototype.waitForSomethingToChange = function (t) {\n      return o(this, void 0, void 0, function () {\n        return a(this, function (i) {\n          switch (i.label) {\n            case 0:\n              return [4, new Promise(function (i) {\n                var o = !1,\n                  n = Date.now(),\n                  a = !1;\n                function s() {\n                  if (a || (window.removeEventListener(\"storage\", s), e.removeFromWaiting(s), clearTimeout(r), a = !0), !o) {\n                    o = !0;\n                    var t = 50 - (Date.now() - n);\n                    t > 0 ? setTimeout(i, t) : i();\n                  }\n                }\n                window.addEventListener(\"storage\", s), e.addToWaiting(s);\n                var r = setTimeout(s, Math.max(0, t - Date.now()));\n              })];\n            case 1:\n              return i.sent(), [2];\n          }\n        });\n      });\n    }, e.addToWaiting = function (t) {\n      this.removeFromWaiting(t), void 0 !== e.waiters && e.waiters.push(t);\n    }, e.removeFromWaiting = function (t) {\n      void 0 !== e.waiters && (e.waiters = e.waiters.filter(function (e) {\n        return e !== t;\n      }));\n    }, e.notifyWaiters = function () {\n      void 0 !== e.waiters && e.waiters.slice().forEach(function (e) {\n        return e();\n      });\n    }, e.prototype.releaseLock = function (e) {\n      return o(this, void 0, void 0, function () {\n        return a(this, function (t) {\n          switch (t.label) {\n            case 0:\n              return [4, this.releaseLock__private__(e)];\n            case 1:\n              return [2, t.sent()];\n          }\n        });\n      });\n    }, e.prototype.releaseLock__private__ = function (t) {\n      return o(this, void 0, void 0, function () {\n        var i, o, r;\n        return a(this, function (a) {\n          switch (a.label) {\n            case 0:\n              return i = window.localStorage, o = s + \"-\" + t, null === (r = i.getItem(o)) ? [2] : (r = JSON.parse(r)).id !== this.id ? [3, 2] : [4, n.default().lock(r.iat)];\n            case 1:\n              a.sent(), this.acquiredIatSet.delete(r.iat), i.removeItem(o), n.default().unlock(r.iat), e.notifyWaiters(), a.label = 2;\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e.lockCorrector = function () {\n      for (var t = Date.now() - 5e3, i = window.localStorage, o = Object.keys(i), n = !1, a = 0; a < o.length; a++) {\n        var r = o[a];\n        if (r.includes(s)) {\n          var c = i.getItem(r);\n          null !== c && (void 0 === (c = JSON.parse(c)).timeRefreshed && c.timeAcquired < t || void 0 !== c.timeRefreshed && c.timeRefreshed < t) && (i.removeItem(r), n = !0);\n        }\n      }\n      n && e.notifyWaiters();\n    }, e.waiters = void 0, e;\n  }();\n  i.default = d;\n}));\nconst s = {\n    timeoutInSeconds: 60\n  },\n  r = {\n    name: \"auth0-spa-js\",\n    version: \"2.1.2\"\n  },\n  c = () => Date.now();\nclass d extends Error {\n  constructor(e, t) {\n    super(t), this.error = e, this.error_description = t, Object.setPrototypeOf(this, d.prototype);\n  }\n  static fromPayload({\n    error: e,\n    error_description: t\n  }) {\n    return new d(e, t);\n  }\n}\nclass u extends d {\n  constructor(e, t, i, o = null) {\n    super(e, t), this.state = i, this.appState = o, Object.setPrototypeOf(this, u.prototype);\n  }\n}\nclass l extends d {\n  constructor() {\n    super(\"timeout\", \"Timeout\"), Object.setPrototypeOf(this, l.prototype);\n  }\n}\nclass h extends l {\n  constructor(e) {\n    super(), this.popup = e, Object.setPrototypeOf(this, h.prototype);\n  }\n}\nclass p extends d {\n  constructor(e) {\n    super(\"cancelled\", \"Popup closed\"), this.popup = e, Object.setPrototypeOf(this, p.prototype);\n  }\n}\nclass m extends d {\n  constructor(e, t, i) {\n    super(e, t), this.mfa_token = i, Object.setPrototypeOf(this, m.prototype);\n  }\n}\nclass f extends d {\n  constructor(e, t) {\n    super(\"missing_refresh_token\", `Missing Refresh Token (audience: '${g(e, [\"default\"])}', scope: '${g(t)}')`), this.audience = e, this.scope = t, Object.setPrototypeOf(this, f.prototype);\n  }\n}\nfunction g(e, t = []) {\n  return e && !t.includes(e) ? e : \"\";\n}\nconst w = () => window.crypto,\n  y = () => {\n    const e = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\";\n    let t = \"\";\n    return Array.from(w().getRandomValues(new Uint8Array(43))).forEach(i => t += e[i % e.length]), t;\n  },\n  k = e => btoa(e),\n  b = t => {\n    var {\n        clientId: i\n      } = t,\n      o = e(t, [\"clientId\"]);\n    return new URLSearchParams((e => Object.keys(e).filter(t => void 0 !== e[t]).reduce((t, i) => Object.assign(Object.assign({}, t), {\n      [i]: e[i]\n    }), {}))(Object.assign({\n      client_id: i\n    }, o))).toString();\n  },\n  v = e => (e => decodeURIComponent(atob(e).split(\"\").map(e => \"%\" + (\"00\" + e.charCodeAt(0).toString(16)).slice(-2)).join(\"\")))(e.replace(/_/g, \"/\").replace(/-/g, \"+\")),\n  _ = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (e, t) {\n      const i = yield fetch(e, t);\n      return {\n        ok: i.ok,\n        json: yield i.json()\n      };\n    });\n    return function _(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }(),\n  I = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (e, t, i) {\n      const o = new AbortController();\n      let n;\n      return t.signal = o.signal, Promise.race([_(e, t), new Promise((e, t) => {\n        n = setTimeout(() => {\n          o.abort(), t(new Error(\"Timeout when executing 'fetch'\"));\n        }, i);\n      })]).finally(() => {\n        clearTimeout(n);\n      });\n    });\n    return function I(_x3, _x4, _x5) {\n      return _ref2.apply(this, arguments);\n    };\n  }(),\n  S = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (e, t, i, o, n, a, s) {\n      return r = {\n        auth: {\n          audience: t,\n          scope: i\n        },\n        timeout: n,\n        fetchUrl: e,\n        fetchOptions: o,\n        useFormData: s\n      }, c = a, new Promise(function (e, t) {\n        const i = new MessageChannel();\n        i.port1.onmessage = function (o) {\n          o.data.error ? t(new Error(o.data.error)) : e(o.data), i.port1.close();\n        }, c.postMessage(r, [i.port2]);\n      });\n      var r, c;\n    });\n    return function S(_x6, _x7, _x8, _x9, _x10, _x11, _x12) {\n      return _ref3.apply(this, arguments);\n    };\n  }(),\n  T = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator(function* (e, t, i, o, n, a, s = 1e4) {\n      return n ? S(e, t, i, o, s, n, a) : I(e, o, s);\n    });\n    return function T(_x13, _x14, _x15, _x16, _x17, _x18) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\nfunction O(_x19, _x20) {\n  return _O.apply(this, arguments);\n}\nfunction _O() {\n  _O = _asyncToGenerator(function* (t, i) {\n    var {\n        baseUrl: o,\n        timeout: n,\n        audience: a,\n        scope: s,\n        auth0Client: c,\n        useFormData: u\n      } = t,\n      l = e(t, [\"baseUrl\", \"timeout\", \"audience\", \"scope\", \"auth0Client\", \"useFormData\"]);\n    const h = u ? b(l) : JSON.stringify(l);\n    return yield function () {\n      var _ref9 = _asyncToGenerator(function* (t, i, o, n, a, s, r) {\n        let c,\n          u = null;\n        for (let e = 0; e < 3; e++) try {\n          c = yield T(t, o, n, a, s, r, i), u = null;\n          break;\n        } catch (e) {\n          u = e;\n        }\n        if (u) throw u;\n        const l = c.json,\n          {\n            error: h,\n            error_description: p\n          } = l,\n          g = e(l, [\"error\", \"error_description\"]),\n          {\n            ok: w\n          } = c;\n        if (!w) {\n          const e = p || `HTTP error. Unable to fetch ${t}`;\n          if (\"mfa_required\" === h) throw new m(h, e, g.mfa_token);\n          if (\"missing_refresh_token\" === h) throw new f(o, n);\n          throw new d(h || \"request_error\", e);\n        }\n        return g;\n      });\n      return function (_x26, _x27, _x28, _x29, _x30, _x31, _x32) {\n        return _ref9.apply(this, arguments);\n      };\n    }()(`${o}/oauth/token`, n, a || \"default\", s, {\n      method: \"POST\",\n      body: h,\n      headers: {\n        \"Content-Type\": u ? \"application/x-www-form-urlencoded\" : \"application/json\",\n        \"Auth0-Client\": btoa(JSON.stringify(c || r))\n      }\n    }, i, u);\n  });\n  return _O.apply(this, arguments);\n}\nconst j = (...e) => {\n  return (t = e.filter(Boolean).join(\" \").trim().split(/\\s+/), Array.from(new Set(t))).join(\" \");\n  var t;\n};\nclass C {\n  constructor(e, t = \"@@auth0spajs@@\", i) {\n    this.prefix = t, this.suffix = i, this.clientId = e.clientId, this.scope = e.scope, this.audience = e.audience;\n  }\n  toKey() {\n    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join(\"::\");\n  }\n  static fromKey(e) {\n    const [t, i, o, n] = e.split(\"::\");\n    return new C({\n      clientId: i,\n      scope: n,\n      audience: o\n    }, t);\n  }\n  static fromCacheEntry(e) {\n    const {\n      scope: t,\n      audience: i,\n      client_id: o\n    } = e;\n    return new C({\n      scope: t,\n      audience: i,\n      clientId: o\n    });\n  }\n}\nclass z {\n  set(e, t) {\n    localStorage.setItem(e, JSON.stringify(t));\n  }\n  get(e) {\n    const t = window.localStorage.getItem(e);\n    if (t) try {\n      return JSON.parse(t);\n    } catch (e) {\n      return;\n    }\n  }\n  remove(e) {\n    localStorage.removeItem(e);\n  }\n  allKeys() {\n    return Object.keys(window.localStorage).filter(e => e.startsWith(\"@@auth0spajs@@\"));\n  }\n}\nclass x {\n  constructor() {\n    this.enclosedCache = function () {\n      let e = {};\n      return {\n        set(t, i) {\n          e[t] = i;\n        },\n        get(t) {\n          const i = e[t];\n          if (i) return i;\n        },\n        remove(t) {\n          delete e[t];\n        },\n        allKeys: () => Object.keys(e)\n      };\n    }();\n  }\n}\nclass P {\n  constructor(e, t, i) {\n    this.cache = e, this.keyManifest = t, this.nowProvider = i || c;\n  }\n  setIdToken(e, t, i) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var o;\n      const n = _this.getIdTokenCacheKey(e);\n      yield _this.cache.set(n, {\n        id_token: t,\n        decodedToken: i\n      }), yield null === (o = _this.keyManifest) || void 0 === o ? void 0 : o.add(n);\n    })();\n  }\n  getIdToken(e) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this2.cache.get(_this2.getIdTokenCacheKey(e.clientId));\n      if (!t && e.scope && e.audience) {\n        const t = yield _this2.get(e);\n        if (!t) return;\n        if (!t.id_token || !t.decodedToken) return;\n        return {\n          id_token: t.id_token,\n          decodedToken: t.decodedToken\n        };\n      }\n      if (t) return {\n        id_token: t.id_token,\n        decodedToken: t.decodedToken\n      };\n    })();\n  }\n  get(e, t = 0) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var i;\n      let o = yield _this3.cache.get(e.toKey());\n      if (!o) {\n        const t = yield _this3.getCacheKeys();\n        if (!t) return;\n        const i = _this3.matchExistingCacheKey(e, t);\n        i && (o = yield _this3.cache.get(i));\n      }\n      if (!o) return;\n      const n = yield _this3.nowProvider(),\n        a = Math.floor(n / 1e3);\n      return o.expiresAt - t < a ? o.body.refresh_token ? (o.body = {\n        refresh_token: o.body.refresh_token\n      }, yield _this3.cache.set(e.toKey(), o), o.body) : (yield _this3.cache.remove(e.toKey()), void (yield null === (i = _this3.keyManifest) || void 0 === i ? void 0 : i.remove(e.toKey()))) : o.body;\n    })();\n  }\n  set(e) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var t;\n      const i = new C({\n          clientId: e.client_id,\n          scope: e.scope,\n          audience: e.audience\n        }),\n        o = yield _this4.wrapCacheEntry(e);\n      yield _this4.cache.set(i.toKey(), o), yield null === (t = _this4.keyManifest) || void 0 === t ? void 0 : t.add(i.toKey());\n    })();\n  }\n  clear(e) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var t;\n      const i = yield _this5.getCacheKeys();\n      i && (yield i.filter(t => !e || t.includes(e)).reduce( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (e, t) {\n          yield e, yield _this5.cache.remove(t);\n        });\n        return function (_x21, _x22) {\n          return _ref5.apply(this, arguments);\n        };\n      }(), Promise.resolve()), yield null === (t = _this5.keyManifest) || void 0 === t ? void 0 : t.clear());\n    })();\n  }\n  wrapCacheEntry(e) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this6.nowProvider();\n      return {\n        body: e,\n        expiresAt: Math.floor(t / 1e3) + e.expires_in\n      };\n    })();\n  }\n  getCacheKeys() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      var e;\n      return _this7.keyManifest ? null === (e = yield _this7.keyManifest.get()) || void 0 === e ? void 0 : e.keys : _this7.cache.allKeys ? _this7.cache.allKeys() : void 0;\n    })();\n  }\n  getIdTokenCacheKey(e) {\n    return new C({\n      clientId: e\n    }, \"@@auth0spajs@@\", \"@@user@@\").toKey();\n  }\n  matchExistingCacheKey(e, t) {\n    return t.filter(t => {\n      var i;\n      const o = C.fromKey(t),\n        n = new Set(o.scope && o.scope.split(\" \")),\n        a = (null === (i = e.scope) || void 0 === i ? void 0 : i.split(\" \")) || [],\n        s = o.scope && a.reduce((e, t) => e && n.has(t), !0);\n      return \"@@auth0spajs@@\" === o.prefix && o.clientId === e.clientId && o.audience === e.audience && s;\n    })[0];\n  }\n}\nclass Z {\n  constructor(e, t, i) {\n    this.storage = e, this.clientId = t, this.cookieDomain = i, this.storageKey = `a0.spajs.txs.${this.clientId}`;\n  }\n  create(e) {\n    this.storage.save(this.storageKey, e, {\n      daysUntilExpire: 1,\n      cookieDomain: this.cookieDomain\n    });\n  }\n  get() {\n    return this.storage.get(this.storageKey);\n  }\n  remove() {\n    this.storage.remove(this.storageKey, {\n      cookieDomain: this.cookieDomain\n    });\n  }\n}\nconst K = e => \"number\" == typeof e,\n  L = [\"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\", \"azp\", \"nonce\", \"auth_time\", \"at_hash\", \"c_hash\", \"acr\", \"amr\", \"sub_jwk\", \"cnf\", \"sip_from_tag\", \"sip_date\", \"sip_callid\", \"sip_cseq_num\", \"sip_via_branch\", \"orig\", \"dest\", \"mky\", \"events\", \"toe\", \"txn\", \"rph\", \"sid\", \"vot\", \"vtm\"],\n  E = e => {\n    if (!e.id_token) throw new Error(\"ID token is required but missing\");\n    const t = (e => {\n      const t = e.split(\".\"),\n        [i, o, n] = t;\n      if (3 !== t.length || !i || !o || !n) throw new Error(\"ID token could not be decoded\");\n      const a = JSON.parse(v(o)),\n        s = {\n          __raw: e\n        },\n        r = {};\n      return Object.keys(a).forEach(e => {\n        s[e] = a[e], L.includes(e) || (r[e] = a[e]);\n      }), {\n        encoded: {\n          header: i,\n          payload: o,\n          signature: n\n        },\n        header: JSON.parse(v(i)),\n        claims: s,\n        user: r\n      };\n    })(e.id_token);\n    if (!t.claims.iss) throw new Error(\"Issuer (iss) claim must be a string present in the ID token\");\n    if (t.claims.iss !== e.iss) throw new Error(`Issuer (iss) claim mismatch in the ID token; expected \"${e.iss}\", found \"${t.claims.iss}\"`);\n    if (!t.user.sub) throw new Error(\"Subject (sub) claim must be a string present in the ID token\");\n    if (\"RS256\" !== t.header.alg) throw new Error(`Signature algorithm of \"${t.header.alg}\" is not supported. Expected the ID token to be signed with \"RS256\".`);\n    if (!t.claims.aud || \"string\" != typeof t.claims.aud && !Array.isArray(t.claims.aud)) throw new Error(\"Audience (aud) claim must be a string or array of strings present in the ID token\");\n    if (Array.isArray(t.claims.aud)) {\n      if (!t.claims.aud.includes(e.aud)) throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e.aud}\" but was not one of \"${t.claims.aud.join(\", \")}\"`);\n      if (t.claims.aud.length > 1) {\n        if (!t.claims.azp) throw new Error(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\");\n        if (t.claims.azp !== e.aud) throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected \"${e.aud}\", found \"${t.claims.azp}\"`);\n      }\n    } else if (t.claims.aud !== e.aud) throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e.aud}\" but found \"${t.claims.aud}\"`);\n    if (e.nonce) {\n      if (!t.claims.nonce) throw new Error(\"Nonce (nonce) claim must be a string present in the ID token\");\n      if (t.claims.nonce !== e.nonce) throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected \"${e.nonce}\", found \"${t.claims.nonce}\"`);\n    }\n    if (e.max_age && !K(t.claims.auth_time)) throw new Error(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\");\n    if (null == t.claims.exp || !K(t.claims.exp)) throw new Error(\"Expiration Time (exp) claim must be a number present in the ID token\");\n    if (!K(t.claims.iat)) throw new Error(\"Issued At (iat) claim must be a number present in the ID token\");\n    const i = e.leeway || 60,\n      o = new Date(e.now || Date.now()),\n      n = new Date(0);\n    if (n.setUTCSeconds(t.claims.exp + i), o > n) throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o}) is after expiration time (${n})`);\n    if (null != t.claims.nbf && K(t.claims.nbf)) {\n      const e = new Date(0);\n      if (e.setUTCSeconds(t.claims.nbf - i), o < e) throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o}) is before ${e}`);\n    }\n    if (null != t.claims.auth_time && K(t.claims.auth_time)) {\n      const n = new Date(0);\n      if (n.setUTCSeconds(parseInt(t.claims.auth_time) + e.max_age + i), o > n) throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o}) is after last auth at ${n}`);\n    }\n    if (e.organization) {\n      const i = e.organization.trim();\n      if (i.startsWith(\"org_\")) {\n        const e = i;\n        if (!t.claims.org_id) throw new Error(\"Organization ID (org_id) claim must be a string present in the ID token\");\n        if (e !== t.claims.org_id) throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected \"${e}\", found \"${t.claims.org_id}\"`);\n      } else {\n        const e = i.toLowerCase();\n        if (!t.claims.org_name) throw new Error(\"Organization Name (org_name) claim must be a string present in the ID token\");\n        if (e !== t.claims.org_name) throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected \"${e}\", found \"${t.claims.org_name}\"`);\n      }\n    }\n    return t;\n  };\nvar U = o(function (e, i) {\n  var o = t && t.__assign || function () {\n    return o = Object.assign || function (e) {\n      for (var t, i = 1, o = arguments.length; i < o; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n      return e;\n    }, o.apply(this, arguments);\n  };\n  function n(e, t) {\n    if (!t) return \"\";\n    var i = \"; \" + e;\n    return !0 === t ? i : i + \"=\" + t;\n  }\n  function a(e, t, i) {\n    return encodeURIComponent(e).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\") + \"=\" + encodeURIComponent(t).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function (e) {\n      if (\"number\" == typeof e.expires) {\n        var t = new Date();\n        t.setMilliseconds(t.getMilliseconds() + 864e5 * e.expires), e.expires = t;\n      }\n      return n(\"Expires\", e.expires ? e.expires.toUTCString() : \"\") + n(\"Domain\", e.domain) + n(\"Path\", e.path) + n(\"Secure\", e.secure) + n(\"SameSite\", e.sameSite);\n    }(i);\n  }\n  function s(e) {\n    for (var t = {}, i = e ? e.split(\"; \") : [], o = /(%[\\dA-F]{2})+/gi, n = 0; n < i.length; n++) {\n      var a = i[n].split(\"=\"),\n        s = a.slice(1).join(\"=\");\n      '\"' === s.charAt(0) && (s = s.slice(1, -1));\n      try {\n        t[a[0].replace(o, decodeURIComponent)] = s.replace(o, decodeURIComponent);\n      } catch (e) {}\n    }\n    return t;\n  }\n  function r() {\n    return s(document.cookie);\n  }\n  function c(e, t, i) {\n    document.cookie = a(e, t, o({\n      path: \"/\"\n    }, i));\n  }\n  i.__esModule = !0, i.encode = a, i.parse = s, i.getAll = r, i.get = function (e) {\n    return r()[e];\n  }, i.set = c, i.remove = function (e, t) {\n    c(e, \"\", o(o({}, t), {\n      expires: -1\n    }));\n  };\n});\ni(U), U.encode, U.parse, U.getAll;\nvar W = U.get,\n  D = U.set,\n  N = U.remove;\nconst X = {\n    get(e) {\n      const t = W(e);\n      if (void 0 !== t) return JSON.parse(t);\n    },\n    save(e, t, i) {\n      let o = {};\n      \"https:\" === window.location.protocol && (o = {\n        secure: !0,\n        sameSite: \"none\"\n      }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), D(e, JSON.stringify(t), o);\n    },\n    remove(e, t) {\n      let i = {};\n      (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), N(e, i);\n    }\n  },\n  R = {\n    get(e) {\n      const t = X.get(e);\n      return t || X.get(`_legacy_${e}`);\n    },\n    save(e, t, i) {\n      let o = {};\n      \"https:\" === window.location.protocol && (o = {\n        secure: !0\n      }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), D(`_legacy_${e}`, JSON.stringify(t), o), X.save(e, t, i);\n    },\n    remove(e, t) {\n      let i = {};\n      (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), N(e, i), X.remove(e, t), X.remove(`_legacy_${e}`, t);\n    }\n  },\n  V = {\n    get(e) {\n      if (\"undefined\" == typeof sessionStorage) return;\n      const t = sessionStorage.getItem(e);\n      return null != t ? JSON.parse(t) : void 0;\n    },\n    save(e, t) {\n      sessionStorage.setItem(e, JSON.stringify(t));\n    },\n    remove(e) {\n      sessionStorage.removeItem(e);\n    }\n  };\nfunction J(e, t, i) {\n  var o = void 0 === t ? null : t,\n    n = function (e, t) {\n      var i = atob(e);\n      if (t) {\n        for (var o = new Uint8Array(i.length), n = 0, a = i.length; n < a; ++n) o[n] = i.charCodeAt(n);\n        return String.fromCharCode.apply(null, new Uint16Array(o.buffer));\n      }\n      return i;\n    }(e, void 0 !== i && i),\n    a = n.indexOf(\"\\n\", 10) + 1,\n    s = n.substring(a) + (o ? \"//# sourceMappingURL=\" + o : \"\"),\n    r = new Blob([s], {\n      type: \"application/javascript\"\n    });\n  return URL.createObjectURL(r);\n}\nvar F,\n  H,\n  G,\n  M,\n  A = (F = \"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9Y29uc3Qgcz1lPT57dmFye2NsaWVudElkOnR9PWUscj1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgcyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiZ0LmluZGV4T2Yocyk8MCYmKHJbc109ZVtzXSk7aWYobnVsbCE9ZSYmImZ1bmN0aW9uIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPHMubGVuZ3RoO28rKyl0LmluZGV4T2Yoc1tvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsc1tvXSkmJihyW3Nbb11dPWVbc1tvXV0pfXJldHVybiByfShlLFsiY2xpZW50SWQiXSk7cmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoKGU9Pk9iamVjdC5rZXlzKGUpLmZpbHRlcigodD0+dm9pZCAwIT09ZVt0XSkpLnJlZHVjZSgoKHQscik9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7W3JdOmVbcl19KSkse30pKShPYmplY3QuYXNzaWduKHtjbGllbnRfaWQ6dH0scikpKS50b1N0cmluZygpfTtsZXQgbz17fTtjb25zdCBuPShlLHQpPT5gJHtlfXwke3R9YDthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoYXN5bmMoe2RhdGE6e3RpbWVvdXQ6ZSxhdXRoOnIsZmV0Y2hVcmw6aSxmZXRjaE9wdGlvbnM6Yyx1c2VGb3JtRGF0YTphfSxwb3J0czpbZl19KT0+e2xldCBwO2NvbnN0e2F1ZGllbmNlOmwsc2NvcGU6dX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2NvbnN0IGU9KChlLHQpPT5vW24oZSx0KV0pKGwsdSk7aWYoIWUpdGhyb3cgbmV3IHQobCx1KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpfWxldCBkLGc7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1kLnNpZ25hbCk7dHJ5e2c9YXdhaXQgUHJvbWlzZS5yYWNlKFsoaD1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsaCkpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIGYucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFnKXJldHVybiBkJiZkLmFib3J0KCksdm9pZCBmLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO3A9YXdhaXQgZy5qc29uKCkscC5yZWZyZXNoX3Rva2VuPygoKGUsdCxyKT0+e29bbih0LHIpXT1lfSkocC5yZWZyZXNoX3Rva2VuLGwsdSksZGVsZXRlIHAucmVmcmVzaF90b2tlbik6KChlLHQpPT57ZGVsZXRlIG9bbihlLHQpXX0pKGwsdSksZi5wb3N0TWVzc2FnZSh7b2s6Zy5vayxqc29uOnB9KX1jYXRjaChlKXtmLnBvc3RNZXNzYWdlKHtvazohMSxqc29uOntlcnJvcjplLmVycm9yLGVycm9yX2Rlc2NyaXB0aW9uOmUubWVzc2FnZX19KX12YXIgaH0pKX0oKTsKCg==\", H = null, G = !1, function (e) {\n    return M = M || J(F, H, G), new Worker(M, e);\n  });\nconst Y = {};\nclass $ {\n  constructor(e, t) {\n    this.cache = e, this.clientId = t, this.manifestKey = this.createManifestKeyFrom(this.clientId);\n  }\n  add(e) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      var t;\n      const i = new Set((null === (t = yield _this8.cache.get(_this8.manifestKey)) || void 0 === t ? void 0 : t.keys) || []);\n      i.add(e), yield _this8.cache.set(_this8.manifestKey, {\n        keys: [...i]\n      });\n    })();\n  }\n  remove(e) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this9.cache.get(_this9.manifestKey);\n      if (t) {\n        const i = new Set(t.keys);\n        return i.delete(e), i.size > 0 ? yield _this9.cache.set(_this9.manifestKey, {\n          keys: [...i]\n        }) : yield _this9.cache.remove(_this9.manifestKey);\n      }\n    })();\n  }\n  get() {\n    return this.cache.get(this.manifestKey);\n  }\n  clear() {\n    return this.cache.remove(this.manifestKey);\n  }\n  createManifestKeyFrom(e) {\n    return `@@auth0spajs@@::${e}`;\n  }\n}\nconst B = {\n    memory: () => new x().enclosedCache,\n    localstorage: () => new z()\n  },\n  q = e => B[e],\n  Q = t => {\n    const {\n        openUrl: i,\n        onRedirect: o\n      } = t,\n      n = e(t, [\"openUrl\", \"onRedirect\"]);\n    return Object.assign(Object.assign({}, n), {\n      openUrl: !1 === i || i ? i : o\n    });\n  },\n  ee = new a();\nclass te {\n  constructor(e) {\n    var _this10 = this;\n    let t, i;\n    if (this.userCache = new x().enclosedCache, this.defaultOptions = {\n      authorizationParams: {\n        scope: \"openid profile email\"\n      },\n      useRefreshTokensFallback: !1,\n      useFormData: !0\n    }, this._releaseLockOnPageHide = /*#__PURE__*/_asyncToGenerator(function* () {\n      yield ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", _this10._releaseLockOnPageHide);\n    }), this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e), {\n      authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e.authorizationParams)\n    }), \"undefined\" != typeof window && (() => {\n      if (!w()) throw new Error(\"For security reasons, `window.crypto` is required to run `auth0-spa-js`.\");\n      if (void 0 === w().subtle) throw new Error(\"\\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\\n    \");\n    })(), e.cache && e.cacheLocation && console.warn(\"Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`.\"), e.cache) i = e.cache;else {\n      if (t = e.cacheLocation || \"memory\", !q(t)) throw new Error(`Invalid cache location \"${t}\"`);\n      i = q(t)();\n    }\n    this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4, this.cookieStorage = !1 === e.legacySameSiteCookie ? X : R, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = (e => `auth0.${e}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1;\n    const o = e.useCookiesForTransactions ? this.cookieStorage : V;\n    var n;\n    this.scope = j(\"openid\", this.options.authorizationParams.scope, this.options.useRefreshTokens ? \"offline_access\" : \"\"), this.transactionManager = new Z(o, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c, this.cacheManager = new P(i, i.allKeys ? void 0 : new $(i, this.options.clientId), this.nowProvider), this.domainUrl = (n = this.options.domain, /^https?:\\/\\//.test(n) ? n : `https://${n}`), this.tokenIssuer = ((e, t) => e ? e.startsWith(\"https://\") ? e : `https://${e}/` : `${t}/`)(this.options.issuer, this.domainUrl), \"undefined\" != typeof window && window.Worker && this.options.useRefreshTokens && \"memory\" === t && (this.worker = new A());\n  }\n  _url(e) {\n    const t = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || r)));\n    return `${this.domainUrl}${e}&auth0Client=${t}`;\n  }\n  _authorizeUrl(e) {\n    return this._url(`/authorize?${b(e)}`);\n  }\n  _verifyIdToken(e, t, i) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const o = yield _this11.nowProvider();\n      return E({\n        iss: _this11.tokenIssuer,\n        aud: _this11.options.clientId,\n        id_token: e,\n        nonce: t,\n        organization: i,\n        leeway: _this11.options.leeway,\n        max_age: (n = _this11.options.authorizationParams.max_age, \"string\" != typeof n ? n : parseInt(n, 10) || void 0),\n        now: o\n      });\n      var n;\n    })();\n  }\n  _processOrgHint(e) {\n    e ? this.cookieStorage.save(this.orgHintCookieName, e, {\n      daysUntilExpire: this.sessionCheckExpiryDays,\n      cookieDomain: this.options.cookieDomain\n    }) : this.cookieStorage.remove(this.orgHintCookieName, {\n      cookieDomain: this.options.cookieDomain\n    });\n  }\n  _prepareAuthorizeUrl(e, t, i) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const o = k(y()),\n        n = k(y()),\n        a = y(),\n        s = (e => {\n          const t = new Uint8Array(e);\n          return (e => {\n            const t = {\n              \"+\": \"-\",\n              \"/\": \"_\",\n              \"=\": \"\"\n            };\n            return e.replace(/[+/=]/g, e => t[e]);\n          })(window.btoa(String.fromCharCode(...Array.from(t))));\n        })(yield function () {\n          var _ref7 = _asyncToGenerator(function* (e) {\n            const t = w().subtle.digest({\n              name: \"SHA-256\"\n            }, new TextEncoder().encode(e));\n            return yield t;\n          });\n          return function (_x23) {\n            return _ref7.apply(this, arguments);\n          };\n        }()(a)),\n        r = ((e, t, i, o, n, a, s, r) => Object.assign(Object.assign(Object.assign({\n          client_id: e.clientId\n        }, e.authorizationParams), i), {\n          scope: j(t, i.scope),\n          response_type: \"code\",\n          response_mode: r || \"query\",\n          state: o,\n          nonce: n,\n          redirect_uri: s || e.authorizationParams.redirect_uri,\n          code_challenge: a,\n          code_challenge_method: \"S256\"\n        }))(_this12.options, _this12.scope, e, o, n, s, e.redirect_uri || _this12.options.authorizationParams.redirect_uri || i, null == t ? void 0 : t.response_mode),\n        c = _this12._authorizeUrl(r);\n      return {\n        nonce: n,\n        code_verifier: a,\n        scope: r.scope,\n        audience: r.audience || \"default\",\n        redirect_uri: r.redirect_uri,\n        state: o,\n        url: c\n      };\n    })();\n  }\n  loginWithPopup(e, t) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      var i;\n      if (e = e || {}, !(t = t || {}).popup && (t.popup = (e => {\n        const t = window.screenX + (window.innerWidth - 400) / 2,\n          i = window.screenY + (window.innerHeight - 600) / 2;\n        return window.open(e, \"auth0:authorize:popup\", `left=${t},top=${i},width=400,height=600,resizable,scrollbars=yes,status=1`);\n      })(\"\"), !t.popup)) throw new Error(\"Unable to open a popup for loginWithPopup - window.open returned `null`\");\n      const o = yield _this13._prepareAuthorizeUrl(e.authorizationParams || {}, {\n        response_mode: \"web_message\"\n      }, window.location.origin);\n      t.popup.location.href = o.url;\n      const n = yield (e => new Promise((t, i) => {\n        let o;\n        const n = setInterval(() => {\n            e.popup && e.popup.closed && (clearInterval(n), clearTimeout(a), window.removeEventListener(\"message\", o, !1), i(new p(e.popup)));\n          }, 1e3),\n          a = setTimeout(() => {\n            clearInterval(n), i(new h(e.popup)), window.removeEventListener(\"message\", o, !1);\n          }, 1e3 * (e.timeoutInSeconds || 60));\n        o = function (s) {\n          if (s.data && \"authorization_response\" === s.data.type) {\n            if (clearTimeout(a), clearInterval(n), window.removeEventListener(\"message\", o, !1), e.popup.close(), s.data.response.error) return i(d.fromPayload(s.data.response));\n            t(s.data.response);\n          }\n        }, window.addEventListener(\"message\", o);\n      }))(Object.assign(Object.assign({}, t), {\n        timeoutInSeconds: t.timeoutInSeconds || _this13.options.authorizeTimeoutInSeconds || 60\n      }));\n      if (o.state !== n.state) throw new d(\"state_mismatch\", \"Invalid state\");\n      const a = (null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.organization) || _this13.options.authorizationParams.organization;\n      yield _this13._requestToken({\n        audience: o.audience,\n        scope: o.scope,\n        code_verifier: o.code_verifier,\n        grant_type: \"authorization_code\",\n        code: n.code,\n        redirect_uri: o.redirect_uri\n      }, {\n        nonceIn: o.nonce,\n        organization: a\n      });\n    })();\n  }\n  getUser() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      var e;\n      const t = yield _this14._getIdTokenFromCache();\n      return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.user;\n    })();\n  }\n  getIdTokenClaims() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      var e;\n      const t = yield _this15._getIdTokenFromCache();\n      return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.claims;\n    })();\n  }\n  loginWithRedirect(t = {}) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      var i;\n      const o = Q(t),\n        {\n          openUrl: n,\n          fragment: a,\n          appState: s\n        } = o,\n        r = e(o, [\"openUrl\", \"fragment\", \"appState\"]),\n        c = (null === (i = r.authorizationParams) || void 0 === i ? void 0 : i.organization) || _this16.options.authorizationParams.organization,\n        d = yield _this16._prepareAuthorizeUrl(r.authorizationParams || {}),\n        {\n          url: u\n        } = d,\n        l = e(d, [\"url\"]);\n      _this16.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l), {\n        appState: s\n      }), c && {\n        organization: c\n      }));\n      const h = a ? `${u}#${a}` : u;\n      n ? yield n(h) : window.location.assign(h);\n    })();\n  }\n  handleRedirectCallback(e = window.location.href) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const t = e.split(\"?\").slice(1);\n      if (0 === t.length) throw new Error(\"There are no query params available for parsing.\");\n      const {\n          state: i,\n          code: o,\n          error: n,\n          error_description: a\n        } = (e => {\n          e.indexOf(\"#\") > -1 && (e = e.substring(0, e.indexOf(\"#\")));\n          const t = new URLSearchParams(e);\n          return {\n            state: t.get(\"state\"),\n            code: t.get(\"code\") || void 0,\n            error: t.get(\"error\") || void 0,\n            error_description: t.get(\"error_description\") || void 0\n          };\n        })(t.join(\"\")),\n        s = _this17.transactionManager.get();\n      if (!s) throw new d(\"missing_transaction\", \"Invalid state\");\n      if (_this17.transactionManager.remove(), n) throw new u(n, a || n, i, s.appState);\n      if (!s.code_verifier || s.state && s.state !== i) throw new d(\"state_mismatch\", \"Invalid state\");\n      const r = s.organization,\n        c = s.nonce,\n        l = s.redirect_uri;\n      return yield _this17._requestToken(Object.assign({\n        audience: s.audience,\n        scope: s.scope,\n        code_verifier: s.code_verifier,\n        grant_type: \"authorization_code\",\n        code: o\n      }, l ? {\n        redirect_uri: l\n      } : {}), {\n        nonceIn: c,\n        organization: r\n      }), {\n        appState: s.appState\n      };\n    })();\n  }\n  checkSession(e) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this18.cookieStorage.get(_this18.isAuthenticatedCookieName)) {\n        if (!_this18.cookieStorage.get(\"auth0.is.authenticated\")) return;\n        _this18.cookieStorage.save(_this18.isAuthenticatedCookieName, !0, {\n          daysUntilExpire: _this18.sessionCheckExpiryDays,\n          cookieDomain: _this18.options.cookieDomain\n        }), _this18.cookieStorage.remove(\"auth0.is.authenticated\");\n      }\n      try {\n        yield _this18.getTokenSilently(e);\n      } catch (e) {}\n    })();\n  }\n  getTokenSilently(e = {}) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      var t;\n      const i = Object.assign(Object.assign({\n          cacheMode: \"on\"\n        }, e), {\n          authorizationParams: Object.assign(Object.assign(Object.assign({}, _this19.options.authorizationParams), e.authorizationParams), {\n            scope: j(_this19.scope, null === (t = e.authorizationParams) || void 0 === t ? void 0 : t.scope)\n          })\n        }),\n        o = yield ((e, t) => {\n          let i = Y[t];\n          return i || (i = e().finally(() => {\n            delete Y[t], i = null;\n          }), Y[t] = i), i;\n        })(() => _this19._getTokenSilently(i), `${_this19.options.clientId}::${i.authorizationParams.audience}::${i.authorizationParams.scope}`);\n      return e.detailedResponse ? o : null == o ? void 0 : o.access_token;\n    })();\n  }\n  _getTokenSilently(t) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const {\n          cacheMode: i\n        } = t,\n        o = e(t, [\"cacheMode\"]);\n      if (\"off\" !== i) {\n        const e = yield _this20._getEntryFromCache({\n          scope: o.authorizationParams.scope,\n          audience: o.authorizationParams.audience || \"default\",\n          clientId: _this20.options.clientId\n        });\n        if (e) return e;\n      }\n      if (\"cache-only\" !== i) {\n        if (!(yield function () {\n          var _ref8 = _asyncToGenerator(function* (e, t = 3) {\n            for (let i = 0; i < t; i++) if (yield e()) return !0;\n            return !1;\n          });\n          return function (_x24) {\n            return _ref8.apply(this, arguments);\n          };\n        }()(() => ee.acquireLock(\"auth0.lock.getTokenSilently\", 5e3), 10))) throw new l();\n        try {\n          if (window.addEventListener(\"pagehide\", _this20._releaseLockOnPageHide), \"off\" !== i) {\n            const e = yield _this20._getEntryFromCache({\n              scope: o.authorizationParams.scope,\n              audience: o.authorizationParams.audience || \"default\",\n              clientId: _this20.options.clientId\n            });\n            if (e) return e;\n          }\n          const e = _this20.options.useRefreshTokens ? yield _this20._getTokenUsingRefreshToken(o) : yield _this20._getTokenFromIFrame(o),\n            {\n              id_token: t,\n              access_token: n,\n              oauthTokenScope: a,\n              expires_in: s\n            } = e;\n          return Object.assign(Object.assign({\n            id_token: t,\n            access_token: n\n          }, a ? {\n            scope: a\n          } : null), {\n            expires_in: s\n          });\n        } finally {\n          yield ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", _this20._releaseLockOnPageHide);\n        }\n      }\n    })();\n  }\n  getTokenWithPopup(e = {}, t = {}) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      var i;\n      const o = Object.assign(Object.assign({}, e), {\n        authorizationParams: Object.assign(Object.assign(Object.assign({}, _this21.options.authorizationParams), e.authorizationParams), {\n          scope: j(_this21.scope, null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.scope)\n        })\n      });\n      t = Object.assign(Object.assign({}, s), t), yield _this21.loginWithPopup(o, t);\n      return (yield _this21.cacheManager.get(new C({\n        scope: o.authorizationParams.scope,\n        audience: o.authorizationParams.audience || \"default\",\n        clientId: _this21.options.clientId\n      }))).access_token;\n    })();\n  }\n  isAuthenticated() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      return !!(yield _this22.getUser());\n    })();\n  }\n  _buildLogoutUrl(t) {\n    null !== t.clientId ? t.clientId = t.clientId || this.options.clientId : delete t.clientId;\n    const i = t.logoutParams || {},\n      {\n        federated: o\n      } = i,\n      n = e(i, [\"federated\"]),\n      a = o ? \"&federated\" : \"\";\n    return this._url(`/v2/logout?${b(Object.assign({\n      clientId: t.clientId\n    }, n))}`) + a;\n  }\n  logout(t = {}) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const i = Q(t),\n        {\n          openUrl: o\n        } = i,\n        n = e(i, [\"openUrl\"]);\n      null === t.clientId ? yield _this23.cacheManager.clear() : yield _this23.cacheManager.clear(t.clientId || _this23.options.clientId), _this23.cookieStorage.remove(_this23.orgHintCookieName, {\n        cookieDomain: _this23.options.cookieDomain\n      }), _this23.cookieStorage.remove(_this23.isAuthenticatedCookieName, {\n        cookieDomain: _this23.options.cookieDomain\n      }), _this23.userCache.remove(\"@@user@@\");\n      const a = _this23._buildLogoutUrl(n);\n      o ? yield o(a) : !1 !== o && window.location.assign(a);\n    })();\n  }\n  _getTokenFromIFrame(e) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const t = Object.assign(Object.assign({}, e.authorizationParams), {\n          prompt: \"none\"\n        }),\n        i = _this24.cookieStorage.get(_this24.orgHintCookieName);\n      i && !t.organization && (t.organization = i);\n      const {\n        url: o,\n        state: n,\n        nonce: a,\n        code_verifier: s,\n        redirect_uri: r,\n        scope: c,\n        audience: u\n      } = yield _this24._prepareAuthorizeUrl(t, {\n        response_mode: \"web_message\"\n      }, window.location.origin);\n      try {\n        if (window.crossOriginIsolated) throw new d(\"login_required\", \"The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.\");\n        const i = e.timeoutInSeconds || _this24.options.authorizeTimeoutInSeconds,\n          h = yield ((e, t, i = 60) => new Promise((o, n) => {\n            const a = window.document.createElement(\"iframe\");\n            a.setAttribute(\"width\", \"0\"), a.setAttribute(\"height\", \"0\"), a.style.display = \"none\";\n            const s = () => {\n              window.document.body.contains(a) && (window.document.body.removeChild(a), window.removeEventListener(\"message\", r, !1));\n            };\n            let r;\n            const c = setTimeout(() => {\n              n(new l()), s();\n            }, 1e3 * i);\n            r = function (e) {\n              if (e.origin != t) return;\n              if (!e.data || \"authorization_response\" !== e.data.type) return;\n              const i = e.source;\n              i && i.close(), e.data.response.error ? n(d.fromPayload(e.data.response)) : o(e.data.response), clearTimeout(c), window.removeEventListener(\"message\", r, !1), setTimeout(s, 2e3);\n            }, window.addEventListener(\"message\", r, !1), window.document.body.appendChild(a), a.setAttribute(\"src\", e);\n          }))(o, _this24.domainUrl, i);\n        if (n !== h.state) throw new d(\"state_mismatch\", \"Invalid state\");\n        const p = yield _this24._requestToken(Object.assign(Object.assign({}, e.authorizationParams), {\n          code_verifier: s,\n          code: h.code,\n          grant_type: \"authorization_code\",\n          redirect_uri: r,\n          timeout: e.authorizationParams.timeout || _this24.httpTimeoutMs\n        }), {\n          nonceIn: a,\n          organization: t.organization\n        });\n        return Object.assign(Object.assign({}, p), {\n          scope: c,\n          oauthTokenScope: p.scope,\n          audience: u\n        });\n      } catch (e) {\n        throw \"login_required\" === e.error && _this24.logout({\n          openUrl: !1\n        }), e;\n      }\n    })();\n  }\n  _getTokenUsingRefreshToken(e) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this25.cacheManager.get(new C({\n        scope: e.authorizationParams.scope,\n        audience: e.authorizationParams.audience || \"default\",\n        clientId: _this25.options.clientId\n      }));\n      if (!(t && t.refresh_token || _this25.worker)) {\n        if (_this25.options.useRefreshTokensFallback) return yield _this25._getTokenFromIFrame(e);\n        throw new f(e.authorizationParams.audience || \"default\", e.authorizationParams.scope);\n      }\n      const i = e.authorizationParams.redirect_uri || _this25.options.authorizationParams.redirect_uri || window.location.origin,\n        o = \"number\" == typeof e.timeoutInSeconds ? 1e3 * e.timeoutInSeconds : null;\n      try {\n        const n = yield _this25._requestToken(Object.assign(Object.assign(Object.assign({}, e.authorizationParams), {\n          grant_type: \"refresh_token\",\n          refresh_token: t && t.refresh_token,\n          redirect_uri: i\n        }), o && {\n          timeout: o\n        }));\n        return Object.assign(Object.assign({}, n), {\n          scope: e.authorizationParams.scope,\n          oauthTokenScope: n.scope,\n          audience: e.authorizationParams.audience || \"default\"\n        });\n      } catch (t) {\n        if ((t.message.indexOf(\"Missing Refresh Token\") > -1 || t.message && t.message.indexOf(\"invalid refresh token\") > -1) && _this25.options.useRefreshTokensFallback) return yield _this25._getTokenFromIFrame(e);\n        throw t;\n      }\n    })();\n  }\n  _saveEntryInCache(t) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const {\n          id_token: i,\n          decodedToken: o\n        } = t,\n        n = e(t, [\"id_token\", \"decodedToken\"]);\n      _this26.userCache.set(\"@@user@@\", {\n        id_token: i,\n        decodedToken: o\n      }), yield _this26.cacheManager.setIdToken(_this26.options.clientId, t.id_token, t.decodedToken), yield _this26.cacheManager.set(n);\n    })();\n  }\n  _getIdTokenFromCache() {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const e = _this27.options.authorizationParams.audience || \"default\",\n        t = yield _this27.cacheManager.getIdToken(new C({\n          clientId: _this27.options.clientId,\n          audience: e,\n          scope: _this27.scope\n        })),\n        i = _this27.userCache.get(\"@@user@@\");\n      return t && t.id_token === (null == i ? void 0 : i.id_token) ? i : (_this27.userCache.set(\"@@user@@\", t), t);\n    })();\n  }\n  _getEntryFromCache({\n    scope: e,\n    audience: t,\n    clientId: i\n  }) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const o = yield _this28.cacheManager.get(new C({\n        scope: e,\n        audience: t,\n        clientId: i\n      }), 60);\n      if (o && o.access_token) {\n        const {\n            access_token: e,\n            oauthTokenScope: t,\n            expires_in: i\n          } = o,\n          n = yield _this28._getIdTokenFromCache();\n        return n && Object.assign(Object.assign({\n          id_token: n.id_token,\n          access_token: e\n        }, t ? {\n          scope: t\n        } : null), {\n          expires_in: i\n        });\n      }\n    })();\n  }\n  _requestToken(e, t) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const {\n          nonceIn: i,\n          organization: o\n        } = t || {},\n        n = yield O(Object.assign({\n          baseUrl: _this29.domainUrl,\n          client_id: _this29.options.clientId,\n          auth0Client: _this29.options.auth0Client,\n          useFormData: _this29.options.useFormData,\n          timeout: _this29.httpTimeoutMs\n        }, e), _this29.worker),\n        a = yield _this29._verifyIdToken(n.id_token, i, o);\n      return yield _this29._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n), {\n        decodedToken: a,\n        scope: e.scope,\n        audience: e.audience || \"default\"\n      }), n.scope ? {\n        oauthTokenScope: n.scope\n      } : null), {\n        client_id: _this29.options.clientId\n      })), _this29.cookieStorage.save(_this29.isAuthenticatedCookieName, !0, {\n        daysUntilExpire: _this29.sessionCheckExpiryDays,\n        cookieDomain: _this29.options.cookieDomain\n      }), _this29._processOrgHint(o || a.claims.org_id), Object.assign(Object.assign({}, n), {\n        decodedToken: a\n      });\n    })();\n  }\n}\nclass ie {}\nfunction oe(_x25) {\n  return _oe.apply(this, arguments);\n}\nfunction _oe() {\n  _oe = _asyncToGenerator(function* (e) {\n    const t = new te(e);\n    return yield t.checkSession(), t;\n  });\n  return _oe.apply(this, arguments);\n}\nexport { te as Auth0Client, u as AuthenticationError, C as CacheKey, d as GenericError, x as InMemoryCache, z as LocalStorageCache, m as MfaRequiredError, f as MissingRefreshTokenError, p as PopupCancelledError, h as PopupTimeoutError, l as TimeoutError, ie as User, oe as createAuth0Client };\n//# sourceMappingURL=auth0-spa-js.production.esm.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}