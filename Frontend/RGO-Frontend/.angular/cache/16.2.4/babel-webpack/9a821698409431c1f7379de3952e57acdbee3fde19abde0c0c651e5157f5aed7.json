{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { VERSION, InjectionToken, Injectable, Optional, Inject, NgModule, inject } from '@angular/core';\nimport { BehaviorSubject, Subject, ReplaySubject, merge, defer, of, iif, from, throwError } from 'rxjs';\nimport { scan, filter, distinctUntilChanged, switchMap, mergeMap, shareReplay, concatMap, catchError, tap, takeUntil, withLatestFrom, map, take, first, mapTo, pluck } from 'rxjs/operators';\nimport * as i4 from '@auth0/auth0-spa-js';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nexport { AuthenticationError, GenericError, InMemoryCache, LocalStorageCache, MfaRequiredError, MissingRefreshTokenError, PopupCancelledError, PopupTimeoutError, TimeoutError, User } from '@auth0/auth0-spa-js';\nimport { Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nvar useragent = {\n  name: '@auth0/auth0-angular',\n  version: '2.2.1'\n};\nclass Auth0ClientFactory {\n  static createClient(configFactory) {\n    const config = configFactory.get();\n    if (!config) {\n      throw new Error('Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set');\n    }\n    return new Auth0Client({\n      ...config,\n      auth0Client: {\n        name: useragent.name,\n        version: useragent.version,\n        env: {\n          'angular/core': VERSION.full\n        }\n      }\n    });\n  }\n}\nconst Auth0ClientService = new InjectionToken('auth0.client');\n\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n *\n * @param def The route definition type\n */\nfunction isHttpInterceptorRouteConfig(def) {\n  return typeof def !== 'string';\n}\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\nconst AuthConfigService = new InjectionToken('auth0-angular.config');\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\nclass AuthClientConfig {\n  constructor(config) {\n    if (config) {\n      this.set(config);\n    }\n  }\n  /**\n   * Sets configuration to be read by other consumers of the service (see usage notes)\n   *\n   * @param config The configuration to set\n   */\n  set(config) {\n    this.config = config;\n  }\n  /**\n   * Gets the config that has been set by other consumers of the service\n   */\n  get() {\n    return this.config;\n  }\n}\nAuthClientConfig.ɵfac = function AuthClientConfig_Factory(t) {\n  return new (t || AuthClientConfig)(i0.ɵɵinject(AuthConfigService, 8));\n};\nAuthClientConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthClientConfig,\n  factory: AuthClientConfig.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthClientConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [AuthConfigService]\n      }]\n    }];\n  }, null);\n})();\nclass AbstractNavigator {\n  constructor(location, injector) {\n    this.location = location;\n    try {\n      this.router = injector.get(Router);\n    } catch {}\n  }\n  /**\n   * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n   * to `window.history.replaceState`.\n   *\n   * @param url The url to navigate to\n   */\n  navigateByUrl(url) {\n    if (this.router) {\n      this.router.navigateByUrl(url);\n      return;\n    }\n    this.location.replaceState(url);\n  }\n}\nAbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) {\n  return new (t || AbstractNavigator)(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.Injector));\n};\nAbstractNavigator.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractNavigator,\n  factory: AbstractNavigator.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractNavigator, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i1.Location\n    }, {\n      type: i0.Injector\n    }];\n  }, null);\n})();\n\n/**\n * Tracks the Authentication State for the SDK\n */\nclass AuthState {\n  constructor(auth0Client) {\n    this.auth0Client = auth0Client;\n    this.isLoadingSubject$ = new BehaviorSubject(true);\n    this.refresh$ = new Subject();\n    this.accessToken$ = new ReplaySubject(1);\n    this.errorSubject$ = new ReplaySubject(1);\n    /**\n     * Emits boolean values indicating the loading state of the SDK.\n     */\n    this.isLoading$ = this.isLoadingSubject$.asObservable();\n    /**\n     * Trigger used to pull User information from the Auth0Client.\n     * Triggers when the access token has changed.\n     */\n    this.accessTokenTrigger$ = this.accessToken$.pipe(scan((acc, current) => ({\n      previous: acc.current,\n      current\n    }), {\n      current: null,\n      previous: null\n    }), filter(({\n      previous,\n      current\n    }) => previous !== current));\n    /**\n     * Trigger used to pull User information from the Auth0Client.\n     * Triggers when an event occurs that needs to retrigger the User Profile information.\n     * Events: Login, Access Token change and Logout\n     */\n    this.isAuthenticatedTrigger$ = this.isLoading$.pipe(filter(loading => !loading), distinctUntilChanged(), switchMap(() =>\n    // To track the value of isAuthenticated over time, we need to merge:\n    //  - the current value\n    //  - the value whenever the access token changes. (this should always be true of there is an access token\n    //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n    //  - the value whenever refreshState$ emits\n    merge(defer(() => this.auth0Client.isAuthenticated()), this.accessTokenTrigger$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())), this.refresh$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())))));\n    /**\n     * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n     * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n     */\n    this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(distinctUntilChanged(), shareReplay(1));\n    /**\n     * Emits details about the authenticated user, or null if not authenticated.\n     */\n    this.user$ = this.isAuthenticatedTrigger$.pipe(concatMap(authenticated => authenticated ? this.auth0Client.getUser() : of(null)), distinctUntilChanged());\n    /**\n     * Emits ID token claims when authenticated, or null if not authenticated.\n     */\n    this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(concatMap(authenticated => authenticated ? this.auth0Client.getIdTokenClaims() : of(null)));\n    /**\n     * Emits errors that occur during login, or when checking for an active session on startup.\n     */\n    this.error$ = this.errorSubject$.asObservable();\n  }\n  /**\n   * Update the isLoading state using the provided value\n   *\n   * @param isLoading The new value for isLoading\n   */\n  setIsLoading(isLoading) {\n    this.isLoadingSubject$.next(isLoading);\n  }\n  /**\n   * Refresh the state to ensure the `isAuthenticated`, `user$` and `idTokenClaims$`\n   * reflect the most up-to-date values from  Auth0Client.\n   */\n  refresh() {\n    this.refresh$.next();\n  }\n  /**\n   * Update the access token, doing so will also refresh the state.\n   *\n   * @param accessToken The new Access Token\n   */\n  setAccessToken(accessToken) {\n    this.accessToken$.next(accessToken);\n  }\n  /**\n   * Emits the error in the `error$` observable.\n   *\n   * @param error The new error\n   */\n  setError(error) {\n    this.errorSubject$.next(error);\n  }\n}\nAuthState.ɵfac = function AuthState_Factory(t) {\n  return new (t || AuthState)(i0.ɵɵinject(Auth0ClientService));\n};\nAuthState.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthState,\n  factory: AuthState.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthState, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i4.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }];\n  }, null);\n})();\nclass AuthService {\n  constructor(auth0Client, configFactory, navigator, authState) {\n    this.auth0Client = auth0Client;\n    this.configFactory = configFactory;\n    this.navigator = navigator;\n    this.authState = authState;\n    this.appStateSubject$ = new ReplaySubject(1);\n    // https://stackoverflow.com/a/41177163\n    this.ngUnsubscribe$ = new Subject();\n    /**\n     * Emits boolean values indicating the loading state of the SDK.\n     */\n    this.isLoading$ = this.authState.isLoading$;\n    /**\n     * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n     * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n     */\n    this.isAuthenticated$ = this.authState.isAuthenticated$;\n    /**\n     * Emits details about the authenticated user, or null if not authenticated.\n     */\n    this.user$ = this.authState.user$;\n    /**\n     * Emits ID token claims when authenticated, or null if not authenticated.\n     */\n    this.idTokenClaims$ = this.authState.idTokenClaims$;\n    /**\n     * Emits errors that occur during login, or when checking for an active session on startup.\n     */\n    this.error$ = this.authState.error$;\n    /**\n     * Emits the value (if any) that was passed to the `loginWithRedirect` method call\n     * but only **after** `handleRedirectCallback` is first called\n     */\n    this.appState$ = this.appStateSubject$.asObservable();\n    const checkSessionOrCallback$ = isCallback => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));\n    this.shouldHandleCallback().pipe(switchMap(isCallback => checkSessionOrCallback$(isCallback).pipe(catchError(error => {\n      const config = this.configFactory.get();\n      this.navigator.navigateByUrl(config.errorPath || '/');\n      this.authState.setError(error);\n      return of(undefined);\n    }))), tap(() => {\n      this.authState.setIsLoading(false);\n    }), takeUntil(this.ngUnsubscribe$)).subscribe();\n  }\n  /**\n   * Called when the service is destroyed\n   */\n  ngOnDestroy() {\n    // https://stackoverflow.com/a/41177163\n    this.ngUnsubscribe$.next();\n    this.ngUnsubscribe$.complete();\n  }\n  /**\n   * ```js\n   * loginWithRedirect(options);\n   * ```\n   *\n   * Performs a redirect to `/authorize` using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated.\n   *\n   * @param options The login options\n   */\n  loginWithRedirect(options) {\n    return from(this.auth0Client.loginWithRedirect(options));\n  }\n  /**\n   * ```js\n   * await loginWithPopup(options);\n   * ```\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   *\n   * IMPORTANT: This method has to be called from an event handler\n   * that was started by the user like a button click, for example,\n   * otherwise the popup will be blocked in most browsers.\n   *\n   * @param options The login options\n   * @param config Configuration for the popup window\n   */\n  loginWithPopup(options, config) {\n    return from(this.auth0Client.loginWithPopup(options, config).then(() => {\n      this.authState.refresh();\n    }));\n  }\n  /**\n   * ```js\n   * logout();\n   * ```\n   *\n   * Clears the application session and performs a redirect to `/v2/logout`, using\n   * the parameters provided as arguments, to clear the Auth0 session.\n   * If the `federated` option is specified it also clears the Identity Provider session.\n   * If the `openUrl` option is set to false, it only clears the application session.\n   * It is invalid to set both the `federated` to true and `openUrl` to `false`,\n   * and an error will be thrown if you do.\n   * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n   *\n   * @param options The logout options\n   */\n  logout(options) {\n    return from(this.auth0Client.logout(options).then(() => {\n      if (options?.openUrl === false || options?.openUrl) {\n        this.authState.refresh();\n      }\n    }));\n  }\n  /**\n   * ```js\n   * getAccessTokenSilently(options).subscribe(token => ...)\n   * ```\n   *\n   * If there's a valid token stored, return it. Otherwise, opens an\n   * iframe with the `/authorize` URL using the parameters provided\n   * as arguments. Random and secure `state` and `nonce` parameters\n   * will be auto-generated. If the response is successful, results\n   * will be valid according to their expiration times.\n   *\n   * If refresh tokens are used, the token endpoint is called directly with the\n   * 'refresh_token' grant. If no refresh token is available to make this call,\n   * the SDK falls back to using an iframe to the '/authorize' URL.\n   *\n   * This method may use a web worker to perform the token call if the in-memory\n   * cache is used.\n   *\n   * If an `audience` value is given to this function, the SDK always falls\n   * back to using an iframe to make the token exchange.\n   *\n   * Note that in all cases, falling back to an iframe requires access to\n   * the `auth0` cookie, and thus will not work in browsers that block third-party\n   * cookies by default (Safari, Brave, etc).\n   *\n   * @param options The options for configuring the token fetch.\n   */\n  getAccessTokenSilently(options = {}) {\n    return of(this.auth0Client).pipe(concatMap(client => options.detailedResponse === true ? client.getTokenSilently({\n      ...options,\n      detailedResponse: true\n    }) : client.getTokenSilently(options)), tap(token => {\n      if (token) {\n        this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token);\n      }\n    }), catchError(error => {\n      this.authState.setError(error);\n      this.authState.refresh();\n      return throwError(error);\n    }));\n  }\n  /**\n   * ```js\n   * getTokenWithPopup(options).subscribe(token => ...)\n   * ```\n   *\n   * Get an access token interactively.\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   */\n  getAccessTokenWithPopup(options) {\n    return of(this.auth0Client).pipe(concatMap(client => client.getTokenWithPopup(options)), tap(token => {\n      if (token) {\n        this.authState.setAccessToken(token);\n      }\n    }), catchError(error => {\n      this.authState.setError(error);\n      this.authState.refresh();\n      return throwError(error);\n    }));\n  }\n  /**\n   * ```js\n   * handleRedirectCallback(url).subscribe(result => ...)\n   * ```\n   *\n   * After the browser redirects back to the callback page,\n   * call `handleRedirectCallback` to handle success and error\n   * responses from Auth0. If the response is successful, results\n   * will be valid according to their expiration times.\n   *\n   * Calling this method also refreshes the authentication and user states.\n   *\n   * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n   */\n  handleRedirectCallback(url) {\n    return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {\n      if (!isLoading) {\n        this.authState.refresh();\n      }\n      const appState = result?.appState;\n      const target = appState?.target ?? '/';\n      if (appState) {\n        this.appStateSubject$.next(appState);\n      }\n      this.navigator.navigateByUrl(target);\n    }), map(([result]) => result));\n  }\n  shouldHandleCallback() {\n    return of(location.search).pipe(map(search => {\n      const searchParams = new URLSearchParams(search);\n      return (searchParams.has('code') || searchParams.has('error')) && searchParams.has('state') && !this.configFactory.get().skipRedirectCallback;\n    }));\n  }\n}\nAuthService.ɵfac = function AuthService_Factory(t) {\n  return new (t || AuthService)(i0.ɵɵinject(Auth0ClientService), i0.ɵɵinject(AuthClientConfig), i0.ɵɵinject(AbstractNavigator), i0.ɵɵinject(AuthState));\n};\nAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthService,\n  factory: AuthService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i4.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }, {\n      type: AuthClientConfig\n    }, {\n      type: AbstractNavigator\n    }, {\n      type: AuthState\n    }];\n  }, null);\n})();\nclass AuthGuard {\n  constructor(auth) {\n    this.auth = auth;\n  }\n  canLoad(route, segments) {\n    return this.auth.isAuthenticated$.pipe(take(1));\n  }\n  canActivate(next, state) {\n    return this.redirectIfUnauthenticated(state);\n  }\n  canActivateChild(childRoute, state) {\n    return this.redirectIfUnauthenticated(state);\n  }\n  redirectIfUnauthenticated(state) {\n    return this.auth.isAuthenticated$.pipe(tap(loggedIn => {\n      if (!loggedIn) {\n        this.auth.loginWithRedirect({\n          appState: {\n            target: state.url\n          }\n        });\n      }\n    }));\n  }\n}\nAuthGuard.ɵfac = function AuthGuard_Factory(t) {\n  return new (t || AuthGuard)(i0.ɵɵinject(AuthService));\n};\nAuthGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthGuard,\n  factory: AuthGuard.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AuthService\n    }];\n  }, null);\n})();\nclass AuthModule {\n  /**\n   * Initialize the authentication module system. Configuration can either be specified here,\n   * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n   *\n   * @param config The optional configuration for the SDK.\n   */\n  static forRoot(config) {\n    return {\n      ngModule: AuthModule,\n      providers: [AuthService, AuthGuard, {\n        provide: AuthConfigService,\n        useValue: config\n      }, {\n        provide: Auth0ClientService,\n        useFactory: Auth0ClientFactory.createClient,\n        deps: [AuthClientConfig]\n      }]\n    };\n  }\n}\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\nAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule\n  }], null, null);\n})();\nconst waitUntil = signal$ => source$ => source$.pipe(mergeMap(value => signal$.pipe(first(), mapTo(value))));\nclass AuthHttpInterceptor {\n  constructor(configFactory, auth0Client, authState, authService) {\n    this.configFactory = configFactory;\n    this.auth0Client = auth0Client;\n    this.authState = authState;\n    this.authService = authService;\n  }\n  intercept(req, next) {\n    const config = this.configFactory.get();\n    if (!config.httpInterceptor?.allowedList) {\n      return next.handle(req);\n    }\n    const isLoaded$ = this.authService.isLoading$.pipe(filter(isLoading => !isLoading));\n    return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap(route => iif(\n    // Check if a route was matched\n    () => route !== null,\n    // If we have a matching route, call getTokenSilently and attach the token to the\n    // outgoing request\n    of(route).pipe(waitUntil(isLoaded$), pluck('tokenOptions'), concatMap(options => this.getAccessTokenSilently(options).pipe(catchError(err => {\n      if (this.allowAnonymous(route, err)) {\n        return of('');\n      }\n      this.authState.setError(err);\n      return throwError(err);\n    }))), switchMap(token => {\n      // Clone the request and attach the bearer token\n      const clone = token ? req.clone({\n        headers: req.headers.set('Authorization', `Bearer ${token}`)\n      }) : req;\n      return next.handle(clone);\n    })),\n    // If the URI being called was not found in our httpInterceptor config, simply\n    // pass the request through without attaching a token\n    next.handle(req))));\n  }\n  /**\n   * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.\n   * Only used internally in the interceptor.\n   *\n   * @param options The options for configuring the token fetch.\n   */\n  getAccessTokenSilently(options) {\n    return of(this.auth0Client).pipe(concatMap(client => client.getTokenSilently(options)), tap(token => this.authState.setAccessToken(token)), catchError(error => {\n      this.authState.refresh();\n      return throwError(error);\n    }));\n  }\n  /**\n   * Strips the query and fragment from the given uri\n   *\n   * @param uri The uri to remove the query and fragment from\n   */\n  stripQueryFrom(uri) {\n    if (uri.indexOf('?') > -1) {\n      uri = uri.substr(0, uri.indexOf('?'));\n    }\n    if (uri.indexOf('#') > -1) {\n      uri = uri.substr(0, uri.indexOf('#'));\n    }\n    return uri;\n  }\n  /**\n   * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n   * the interceptor route configuration.\n   *\n   * @param route The route to test\n   * @param request The HTTP request\n   */\n  canAttachToken(route, request) {\n    const testPrimitive = value => {\n      if (!value) {\n        return false;\n      }\n      const requestPath = this.stripQueryFrom(request.url);\n      if (value === requestPath) {\n        return true;\n      }\n      // If the URL ends with an asterisk, match using startsWith.\n      return value.indexOf('*') === value.length - 1 && request.url.startsWith(value.substr(0, value.length - 1));\n    };\n    if (isHttpInterceptorRouteConfig(route)) {\n      if (route.httpMethod && route.httpMethod !== request.method) {\n        return false;\n      }\n      /* istanbul ignore if */\n      if (!route.uri && !route.uriMatcher) {\n        console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');\n      }\n      return route.uriMatcher ? route.uriMatcher(request.url) : testPrimitive(route.uri);\n    }\n    return testPrimitive(route);\n  }\n  /**\n   * Tries to match a route from the SDK configuration to the HTTP request.\n   * If a match is found, the route configuration is returned.\n   *\n   * @param request The Http request\n   * @param config HttpInterceptorConfig\n   */\n  findMatchingRoute(request, config) {\n    return from(config.allowedList).pipe(first(route => this.canAttachToken(route, request), null));\n  }\n  allowAnonymous(route, err) {\n    return !!route && isHttpInterceptorRouteConfig(route) && !!route.allowAnonymous && ['login_required', 'consent_required', 'missing_refresh_token'].includes(err.error);\n  }\n}\nAuthHttpInterceptor.ɵfac = function AuthHttpInterceptor_Factory(t) {\n  return new (t || AuthHttpInterceptor)(i0.ɵɵinject(AuthClientConfig), i0.ɵɵinject(Auth0ClientService), i0.ɵɵinject(AuthState), i0.ɵɵinject(AuthService));\n};\nAuthHttpInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthHttpInterceptor,\n  factory: AuthHttpInterceptor.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthHttpInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthClientConfig\n    }, {\n      type: i4.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }, {\n      type: AuthState\n    }, {\n      type: AuthService\n    }];\n  }, null);\n})();\n\n/**\n * Initialize the authentication system. Configuration can either be specified here,\n * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n *\n * Note: Should only be used as of Angular 15, and should not be added to a component's providers.\n *\n * @param config The optional configuration for the SDK.\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideAuth0(),\n *   ],\n * });\n */\nfunction provideAuth0(config) {\n  return [AuthService, AuthHttpInterceptor, AuthGuard, {\n    provide: AuthConfigService,\n    useValue: config\n  }, {\n    provide: Auth0ClientService,\n    useFactory: Auth0ClientFactory.createClient,\n    deps: [AuthClientConfig]\n  }];\n}\n\n/**\n * Functional AuthGuard to ensure routes can only be accessed when authenticated.\n *\n * Note: Should only be used as of Angular 15\n *\n * @param route Contains the information about a route associated with a component loaded in an outlet at a particular moment in time.\n * @param state Represents the state of the router at a moment in time.\n * @returns An Observable, indicating if the route can be accessed or not\n */\nconst authGuardFn = (route, state) => inject(AuthGuard).canActivate(route, state);\n/**\n * Functional AuthHttpInterceptor to include the access token in matching requests.\n *\n * Note: Should only be used as of Angular 15\n *\n * @param req An outgoing HTTP request with an optional typed body.\n * @param handle Represents the next interceptor in an interceptor chain, or the real backend if there are no\n * further interceptors.\n * @returns An Observable representing the intercepted HttpRequest\n */\nconst authHttpInterceptorFn = (req, handle) => inject(AuthHttpInterceptor).intercept(req, {\n  handle\n});\n\n/*\n * Public API Surface of auth0-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Auth0ClientFactory, Auth0ClientService, AuthClientConfig, AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, AuthState, authGuardFn, authHttpInterceptorFn, isHttpInterceptorRouteConfig, provideAuth0 };","map":{"version":3,"names":["i0","VERSION","InjectionToken","Injectable","Optional","Inject","NgModule","inject","BehaviorSubject","Subject","ReplaySubject","merge","defer","of","iif","from","throwError","scan","filter","distinctUntilChanged","switchMap","mergeMap","shareReplay","concatMap","catchError","tap","takeUntil","withLatestFrom","map","take","first","mapTo","pluck","i4","Auth0Client","AuthenticationError","GenericError","InMemoryCache","LocalStorageCache","MfaRequiredError","MissingRefreshTokenError","PopupCancelledError","PopupTimeoutError","TimeoutError","User","Router","i1","useragent","name","version","Auth0ClientFactory","createClient","configFactory","config","get","Error","auth0Client","env","full","Auth0ClientService","isHttpInterceptorRouteConfig","def","AuthConfigService","AuthClientConfig","constructor","set","ɵfac","AuthClientConfig_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","undefined","decorators","AbstractNavigator","location","injector","router","navigateByUrl","url","replaceState","AbstractNavigator_Factory","Location","Injector","AuthState","isLoadingSubject$","refresh$","accessToken$","errorSubject$","isLoading$","asObservable","accessTokenTrigger$","pipe","acc","current","previous","isAuthenticatedTrigger$","loading","isAuthenticated","isAuthenticated$","user$","authenticated","getUser","idTokenClaims$","getIdTokenClaims","error$","setIsLoading","isLoading","next","refresh","setAccessToken","accessToken","setError","error","AuthState_Factory","AuthService","navigator","authState","appStateSubject$","ngUnsubscribe$","appState$","checkSessionOrCallback$","isCallback","handleRedirectCallback","checkSession","shouldHandleCallback","errorPath","subscribe","ngOnDestroy","complete","loginWithRedirect","options","loginWithPopup","then","logout","openUrl","getAccessTokenSilently","client","detailedResponse","getTokenSilently","access_token","getAccessTokenWithPopup","getTokenWithPopup","result","appState","target","search","searchParams","URLSearchParams","has","skipRedirectCallback","AuthService_Factory","AuthGuard","auth","canLoad","route","segments","canActivate","state","redirectIfUnauthenticated","canActivateChild","childRoute","loggedIn","AuthGuard_Factory","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","AuthModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","waitUntil","signal$","source$","value","AuthHttpInterceptor","authService","intercept","req","httpInterceptor","allowedList","handle","isLoaded$","findMatchingRoute","err","allowAnonymous","clone","headers","stripQueryFrom","uri","indexOf","substr","canAttachToken","request","testPrimitive","requestPath","length","startsWith","httpMethod","method","uriMatcher","console","warn","includes","AuthHttpInterceptor_Factory","provideAuth0","authGuardFn","authHttpInterceptorFn"],"sources":["C:/Users/HP/Desktop/GOP/RGO-Client/Frontend/RGO-Frontend/node_modules/@auth0/auth0-angular/fesm2020/auth0-auth0-angular.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { VERSION, InjectionToken, Injectable, Optional, Inject, NgModule, inject } from '@angular/core';\nimport { BehaviorSubject, Subject, ReplaySubject, merge, defer, of, iif, from, throwError } from 'rxjs';\nimport { scan, filter, distinctUntilChanged, switchMap, mergeMap, shareReplay, concatMap, catchError, tap, takeUntil, withLatestFrom, map, take, first, mapTo, pluck } from 'rxjs/operators';\nimport * as i4 from '@auth0/auth0-spa-js';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nexport { AuthenticationError, GenericError, InMemoryCache, LocalStorageCache, MfaRequiredError, MissingRefreshTokenError, PopupCancelledError, PopupTimeoutError, TimeoutError, User } from '@auth0/auth0-spa-js';\nimport { Router } from '@angular/router';\nimport * as i1 from '@angular/common';\n\nvar useragent = { name: '@auth0/auth0-angular', version: '2.2.1' };\n\nclass Auth0ClientFactory {\n    static createClient(configFactory) {\n        const config = configFactory.get();\n        if (!config) {\n            throw new Error('Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set');\n        }\n        return new Auth0Client({\n            ...config,\n            auth0Client: {\n                name: useragent.name,\n                version: useragent.version,\n                env: {\n                    'angular/core': VERSION.full,\n                },\n            },\n        });\n    }\n}\nconst Auth0ClientService = new InjectionToken('auth0.client');\n\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n *\n * @param def The route definition type\n */\nfunction isHttpInterceptorRouteConfig(def) {\n    return typeof def !== 'string';\n}\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\nconst AuthConfigService = new InjectionToken('auth0-angular.config');\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\nclass AuthClientConfig {\n    constructor(config) {\n        if (config) {\n            this.set(config);\n        }\n    }\n    /**\n     * Sets configuration to be read by other consumers of the service (see usage notes)\n     *\n     * @param config The configuration to set\n     */\n    set(config) {\n        this.config = config;\n    }\n    /**\n     * Gets the config that has been set by other consumers of the service\n     */\n    get() {\n        return this.config;\n    }\n}\nAuthClientConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthClientConfig, deps: [{ token: AuthConfigService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nAuthClientConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthClientConfig, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthClientConfig, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [AuthConfigService]\n                }] }]; } });\n\nclass AbstractNavigator {\n    constructor(location, injector) {\n        this.location = location;\n        try {\n            this.router = injector.get(Router);\n        }\n        catch { }\n    }\n    /**\n     * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n     * to `window.history.replaceState`.\n     *\n     * @param url The url to navigate to\n     */\n    navigateByUrl(url) {\n        if (this.router) {\n            this.router.navigateByUrl(url);\n            return;\n        }\n        this.location.replaceState(url);\n    }\n}\nAbstractNavigator.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AbstractNavigator, deps: [{ token: i1.Location }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\nAbstractNavigator.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AbstractNavigator, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AbstractNavigator, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i1.Location }, { type: i0.Injector }]; } });\n\n/**\n * Tracks the Authentication State for the SDK\n */\nclass AuthState {\n    constructor(auth0Client) {\n        this.auth0Client = auth0Client;\n        this.isLoadingSubject$ = new BehaviorSubject(true);\n        this.refresh$ = new Subject();\n        this.accessToken$ = new ReplaySubject(1);\n        this.errorSubject$ = new ReplaySubject(1);\n        /**\n         * Emits boolean values indicating the loading state of the SDK.\n         */\n        this.isLoading$ = this.isLoadingSubject$.asObservable();\n        /**\n         * Trigger used to pull User information from the Auth0Client.\n         * Triggers when the access token has changed.\n         */\n        this.accessTokenTrigger$ = this.accessToken$.pipe(scan((acc, current) => ({\n            previous: acc.current,\n            current,\n        }), { current: null, previous: null }), filter(({ previous, current }) => previous !== current));\n        /**\n         * Trigger used to pull User information from the Auth0Client.\n         * Triggers when an event occurs that needs to retrigger the User Profile information.\n         * Events: Login, Access Token change and Logout\n         */\n        this.isAuthenticatedTrigger$ = this.isLoading$.pipe(filter((loading) => !loading), distinctUntilChanged(), switchMap(() => \n        // To track the value of isAuthenticated over time, we need to merge:\n        //  - the current value\n        //  - the value whenever the access token changes. (this should always be true of there is an access token\n        //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n        //  - the value whenever refreshState$ emits\n        merge(defer(() => this.auth0Client.isAuthenticated()), this.accessTokenTrigger$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())), this.refresh$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())))));\n        /**\n         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n         */\n        this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(distinctUntilChanged(), shareReplay(1));\n        /**\n         * Emits details about the authenticated user, or null if not authenticated.\n         */\n        this.user$ = this.isAuthenticatedTrigger$.pipe(concatMap((authenticated) => authenticated ? this.auth0Client.getUser() : of(null)), distinctUntilChanged());\n        /**\n         * Emits ID token claims when authenticated, or null if not authenticated.\n         */\n        this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(concatMap((authenticated) => authenticated ? this.auth0Client.getIdTokenClaims() : of(null)));\n        /**\n         * Emits errors that occur during login, or when checking for an active session on startup.\n         */\n        this.error$ = this.errorSubject$.asObservable();\n    }\n    /**\n     * Update the isLoading state using the provided value\n     *\n     * @param isLoading The new value for isLoading\n     */\n    setIsLoading(isLoading) {\n        this.isLoadingSubject$.next(isLoading);\n    }\n    /**\n     * Refresh the state to ensure the `isAuthenticated`, `user$` and `idTokenClaims$`\n     * reflect the most up-to-date values from  Auth0Client.\n     */\n    refresh() {\n        this.refresh$.next();\n    }\n    /**\n     * Update the access token, doing so will also refresh the state.\n     *\n     * @param accessToken The new Access Token\n     */\n    setAccessToken(accessToken) {\n        this.accessToken$.next(accessToken);\n    }\n    /**\n     * Emits the error in the `error$` observable.\n     *\n     * @param error The new error\n     */\n    setError(error) {\n        this.errorSubject$.next(error);\n    }\n}\nAuthState.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthState, deps: [{ token: Auth0ClientService }], target: i0.ɵɵFactoryTarget.Injectable });\nAuthState.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthState, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthState, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i4.Auth0Client, decorators: [{\n                    type: Inject,\n                    args: [Auth0ClientService]\n                }] }]; } });\n\nclass AuthService {\n    constructor(auth0Client, configFactory, navigator, authState) {\n        this.auth0Client = auth0Client;\n        this.configFactory = configFactory;\n        this.navigator = navigator;\n        this.authState = authState;\n        this.appStateSubject$ = new ReplaySubject(1);\n        // https://stackoverflow.com/a/41177163\n        this.ngUnsubscribe$ = new Subject();\n        /**\n         * Emits boolean values indicating the loading state of the SDK.\n         */\n        this.isLoading$ = this.authState.isLoading$;\n        /**\n         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n         */\n        this.isAuthenticated$ = this.authState.isAuthenticated$;\n        /**\n         * Emits details about the authenticated user, or null if not authenticated.\n         */\n        this.user$ = this.authState.user$;\n        /**\n         * Emits ID token claims when authenticated, or null if not authenticated.\n         */\n        this.idTokenClaims$ = this.authState.idTokenClaims$;\n        /**\n         * Emits errors that occur during login, or when checking for an active session on startup.\n         */\n        this.error$ = this.authState.error$;\n        /**\n         * Emits the value (if any) that was passed to the `loginWithRedirect` method call\n         * but only **after** `handleRedirectCallback` is first called\n         */\n        this.appState$ = this.appStateSubject$.asObservable();\n        const checkSessionOrCallback$ = (isCallback) => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));\n        this.shouldHandleCallback()\n            .pipe(switchMap((isCallback) => checkSessionOrCallback$(isCallback).pipe(catchError((error) => {\n            const config = this.configFactory.get();\n            this.navigator.navigateByUrl(config.errorPath || '/');\n            this.authState.setError(error);\n            return of(undefined);\n        }))), tap(() => {\n            this.authState.setIsLoading(false);\n        }), takeUntil(this.ngUnsubscribe$))\n            .subscribe();\n    }\n    /**\n     * Called when the service is destroyed\n     */\n    ngOnDestroy() {\n        // https://stackoverflow.com/a/41177163\n        this.ngUnsubscribe$.next();\n        this.ngUnsubscribe$.complete();\n    }\n    /**\n     * ```js\n     * loginWithRedirect(options);\n     * ```\n     *\n     * Performs a redirect to `/authorize` using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     *\n     * @param options The login options\n     */\n    loginWithRedirect(options) {\n        return from(this.auth0Client.loginWithRedirect(options));\n    }\n    /**\n     * ```js\n     * await loginWithPopup(options);\n     * ```\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     *\n     * IMPORTANT: This method has to be called from an event handler\n     * that was started by the user like a button click, for example,\n     * otherwise the popup will be blocked in most browsers.\n     *\n     * @param options The login options\n     * @param config Configuration for the popup window\n     */\n    loginWithPopup(options, config) {\n        return from(this.auth0Client.loginWithPopup(options, config).then(() => {\n            this.authState.refresh();\n        }));\n    }\n    /**\n     * ```js\n     * logout();\n     * ```\n     *\n     * Clears the application session and performs a redirect to `/v2/logout`, using\n     * the parameters provided as arguments, to clear the Auth0 session.\n     * If the `federated` option is specified it also clears the Identity Provider session.\n     * If the `openUrl` option is set to false, it only clears the application session.\n     * It is invalid to set both the `federated` to true and `openUrl` to `false`,\n     * and an error will be thrown if you do.\n     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n     *\n     * @param options The logout options\n     */\n    logout(options) {\n        return from(this.auth0Client.logout(options).then(() => {\n            if (options?.openUrl === false || options?.openUrl) {\n                this.authState.refresh();\n            }\n        }));\n    }\n    /**\n     * ```js\n     * getAccessTokenSilently(options).subscribe(token => ...)\n     * ```\n     *\n     * If there's a valid token stored, return it. Otherwise, opens an\n     * iframe with the `/authorize` URL using the parameters provided\n     * as arguments. Random and secure `state` and `nonce` parameters\n     * will be auto-generated. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * If refresh tokens are used, the token endpoint is called directly with the\n     * 'refresh_token' grant. If no refresh token is available to make this call,\n     * the SDK falls back to using an iframe to the '/authorize' URL.\n     *\n     * This method may use a web worker to perform the token call if the in-memory\n     * cache is used.\n     *\n     * If an `audience` value is given to this function, the SDK always falls\n     * back to using an iframe to make the token exchange.\n     *\n     * Note that in all cases, falling back to an iframe requires access to\n     * the `auth0` cookie, and thus will not work in browsers that block third-party\n     * cookies by default (Safari, Brave, etc).\n     *\n     * @param options The options for configuring the token fetch.\n     */\n    getAccessTokenSilently(options = {}) {\n        return of(this.auth0Client).pipe(concatMap((client) => options.detailedResponse === true\n            ? client.getTokenSilently({ ...options, detailedResponse: true })\n            : client.getTokenSilently(options)), tap((token) => {\n            if (token) {\n                this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token);\n            }\n        }), catchError((error) => {\n            this.authState.setError(error);\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * ```js\n     * getTokenWithPopup(options).subscribe(token => ...)\n     * ```\n     *\n     * Get an access token interactively.\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     */\n    getAccessTokenWithPopup(options) {\n        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenWithPopup(options)), tap((token) => {\n            if (token) {\n                this.authState.setAccessToken(token);\n            }\n        }), catchError((error) => {\n            this.authState.setError(error);\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * ```js\n     * handleRedirectCallback(url).subscribe(result => ...)\n     * ```\n     *\n     * After the browser redirects back to the callback page,\n     * call `handleRedirectCallback` to handle success and error\n     * responses from Auth0. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * Calling this method also refreshes the authentication and user states.\n     *\n     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n     */\n    handleRedirectCallback(url) {\n        return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {\n            if (!isLoading) {\n                this.authState.refresh();\n            }\n            const appState = result?.appState;\n            const target = appState?.target ?? '/';\n            if (appState) {\n                this.appStateSubject$.next(appState);\n            }\n            this.navigator.navigateByUrl(target);\n        }), map(([result]) => result));\n    }\n    shouldHandleCallback() {\n        return of(location.search).pipe(map((search) => {\n            const searchParams = new URLSearchParams(search);\n            return ((searchParams.has('code') || searchParams.has('error')) &&\n                searchParams.has('state') &&\n                !this.configFactory.get().skipRedirectCallback);\n        }));\n    }\n}\nAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthService, deps: [{ token: Auth0ClientService }, { token: AuthClientConfig }, { token: AbstractNavigator }, { token: AuthState }], target: i0.ɵɵFactoryTarget.Injectable });\nAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i4.Auth0Client, decorators: [{\n                    type: Inject,\n                    args: [Auth0ClientService]\n                }] }, { type: AuthClientConfig }, { type: AbstractNavigator }, { type: AuthState }]; } });\n\nclass AuthGuard {\n    constructor(auth) {\n        this.auth = auth;\n    }\n    canLoad(route, segments) {\n        return this.auth.isAuthenticated$.pipe(take(1));\n    }\n    canActivate(next, state) {\n        return this.redirectIfUnauthenticated(state);\n    }\n    canActivateChild(childRoute, state) {\n        return this.redirectIfUnauthenticated(state);\n    }\n    redirectIfUnauthenticated(state) {\n        return this.auth.isAuthenticated$.pipe(tap((loggedIn) => {\n            if (!loggedIn) {\n                this.auth.loginWithRedirect({\n                    appState: { target: state.url },\n                });\n            }\n        }));\n    }\n}\nAuthGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthGuard, deps: [{ token: AuthService }], target: i0.ɵɵFactoryTarget.Injectable });\nAuthGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthGuard, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthGuard, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: AuthService }]; } });\n\nclass AuthModule {\n    /**\n     * Initialize the authentication module system. Configuration can either be specified here,\n     * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n     *\n     * @param config The optional configuration for the SDK.\n     */\n    static forRoot(config) {\n        return {\n            ngModule: AuthModule,\n            providers: [\n                AuthService,\n                AuthGuard,\n                {\n                    provide: AuthConfigService,\n                    useValue: config,\n                },\n                {\n                    provide: Auth0ClientService,\n                    useFactory: Auth0ClientFactory.createClient,\n                    deps: [AuthClientConfig],\n                },\n            ],\n        };\n    }\n}\nAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthModule });\nAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthModule, decorators: [{\n            type: NgModule\n        }] });\n\nconst waitUntil = (signal$) => (source$) => source$.pipe(mergeMap((value) => signal$.pipe(first(), mapTo(value))));\nclass AuthHttpInterceptor {\n    constructor(configFactory, auth0Client, authState, authService) {\n        this.configFactory = configFactory;\n        this.auth0Client = auth0Client;\n        this.authState = authState;\n        this.authService = authService;\n    }\n    intercept(req, next) {\n        const config = this.configFactory.get();\n        if (!config.httpInterceptor?.allowedList) {\n            return next.handle(req);\n        }\n        const isLoaded$ = this.authService.isLoading$.pipe(filter((isLoading) => !isLoading));\n        return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap((route) => iif(\n        // Check if a route was matched\n        () => route !== null, \n        // If we have a matching route, call getTokenSilently and attach the token to the\n        // outgoing request\n        of(route).pipe(waitUntil(isLoaded$), pluck('tokenOptions'), concatMap((options) => this.getAccessTokenSilently(options).pipe(catchError((err) => {\n            if (this.allowAnonymous(route, err)) {\n                return of('');\n            }\n            this.authState.setError(err);\n            return throwError(err);\n        }))), switchMap((token) => {\n            // Clone the request and attach the bearer token\n            const clone = token\n                ? req.clone({\n                    headers: req.headers.set('Authorization', `Bearer ${token}`),\n                })\n                : req;\n            return next.handle(clone);\n        })), \n        // If the URI being called was not found in our httpInterceptor config, simply\n        // pass the request through without attaching a token\n        next.handle(req))));\n    }\n    /**\n     * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.\n     * Only used internally in the interceptor.\n     *\n     * @param options The options for configuring the token fetch.\n     */\n    getAccessTokenSilently(options) {\n        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenSilently(options)), tap((token) => this.authState.setAccessToken(token)), catchError((error) => {\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * Strips the query and fragment from the given uri\n     *\n     * @param uri The uri to remove the query and fragment from\n     */\n    stripQueryFrom(uri) {\n        if (uri.indexOf('?') > -1) {\n            uri = uri.substr(0, uri.indexOf('?'));\n        }\n        if (uri.indexOf('#') > -1) {\n            uri = uri.substr(0, uri.indexOf('#'));\n        }\n        return uri;\n    }\n    /**\n     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n     * the interceptor route configuration.\n     *\n     * @param route The route to test\n     * @param request The HTTP request\n     */\n    canAttachToken(route, request) {\n        const testPrimitive = (value) => {\n            if (!value) {\n                return false;\n            }\n            const requestPath = this.stripQueryFrom(request.url);\n            if (value === requestPath) {\n                return true;\n            }\n            // If the URL ends with an asterisk, match using startsWith.\n            return (value.indexOf('*') === value.length - 1 &&\n                request.url.startsWith(value.substr(0, value.length - 1)));\n        };\n        if (isHttpInterceptorRouteConfig(route)) {\n            if (route.httpMethod && route.httpMethod !== request.method) {\n                return false;\n            }\n            /* istanbul ignore if */\n            if (!route.uri && !route.uriMatcher) {\n                console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');\n            }\n            return route.uriMatcher\n                ? route.uriMatcher(request.url)\n                : testPrimitive(route.uri);\n        }\n        return testPrimitive(route);\n    }\n    /**\n     * Tries to match a route from the SDK configuration to the HTTP request.\n     * If a match is found, the route configuration is returned.\n     *\n     * @param request The Http request\n     * @param config HttpInterceptorConfig\n     */\n    findMatchingRoute(request, config) {\n        return from(config.allowedList).pipe(first((route) => this.canAttachToken(route, request), null));\n    }\n    allowAnonymous(route, err) {\n        return (!!route &&\n            isHttpInterceptorRouteConfig(route) &&\n            !!route.allowAnonymous &&\n            ['login_required', 'consent_required', 'missing_refresh_token'].includes(err.error));\n    }\n}\nAuthHttpInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthHttpInterceptor, deps: [{ token: AuthClientConfig }, { token: Auth0ClientService }, { token: AuthState }, { token: AuthService }], target: i0.ɵɵFactoryTarget.Injectable });\nAuthHttpInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthHttpInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: AuthHttpInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: AuthClientConfig }, { type: i4.Auth0Client, decorators: [{\n                    type: Inject,\n                    args: [Auth0ClientService]\n                }] }, { type: AuthState }, { type: AuthService }]; } });\n\n/**\n * Initialize the authentication system. Configuration can either be specified here,\n * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n *\n * Note: Should only be used as of Angular 15, and should not be added to a component's providers.\n *\n * @param config The optional configuration for the SDK.\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideAuth0(),\n *   ],\n * });\n */\nfunction provideAuth0(config) {\n    return [\n        AuthService,\n        AuthHttpInterceptor,\n        AuthGuard,\n        {\n            provide: AuthConfigService,\n            useValue: config,\n        },\n        {\n            provide: Auth0ClientService,\n            useFactory: Auth0ClientFactory.createClient,\n            deps: [AuthClientConfig],\n        },\n    ];\n}\n\n/**\n * Functional AuthGuard to ensure routes can only be accessed when authenticated.\n *\n * Note: Should only be used as of Angular 15\n *\n * @param route Contains the information about a route associated with a component loaded in an outlet at a particular moment in time.\n * @param state Represents the state of the router at a moment in time.\n * @returns An Observable, indicating if the route can be accessed or not\n */\nconst authGuardFn = (route, state) => inject(AuthGuard).canActivate(route, state);\n/**\n * Functional AuthHttpInterceptor to include the access token in matching requests.\n *\n * Note: Should only be used as of Angular 15\n *\n * @param req An outgoing HTTP request with an optional typed body.\n * @param handle Represents the next interceptor in an interceptor chain, or the real backend if there are no\n * further interceptors.\n * @returns An Observable representing the intercepted HttpRequest\n */\nconst authHttpInterceptorFn = (req, handle) => inject(AuthHttpInterceptor).intercept(req, { handle });\n\n/*\n * Public API Surface of auth0-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Auth0ClientFactory, Auth0ClientService, AuthClientConfig, AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, AuthState, authGuardFn, authHttpInterceptorFn, isHttpInterceptorRouteConfig, provideAuth0 };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}